/*
Deployment script for DataCenter-qlikview

This code was generated by a tool.
Changes to this file may cause incorrect behavior and will be lost if
the code is regenerated.
*/

GO
SET ANSI_NULLS, ANSI_PADDING, ANSI_WARNINGS, ARITHABORT, CONCAT_NULL_YIELDS_NULL, QUOTED_IDENTIFIER ON;

SET NUMERIC_ROUNDABORT OFF;


GO
:setvar PriorityDatabase "cele"
:setvar PriorityServer "Priority"
:setvar RedeployJobs "YES"
:setvar DatabaseName "DataCenter-qlikview"
:setvar DefaultFilePrefix "DataCenter-qlikview"
:setvar DefaultDataPath "C:\var\opt\mssql\data\"
:setvar DefaultLogPath "C:\var\opt\mssql\data\"

GO
:on error exit
GO
/*
Detect SQLCMD mode and disable script execution if SQLCMD mode is not supported.
To re-enable the script after enabling SQLCMD mode, execute the following:
SET NOEXEC OFF; 
*/
:setvar __IsSqlCmdEnabled "True"
GO
IF N'$(__IsSqlCmdEnabled)' NOT LIKE N'True'
    BEGIN
        PRINT N'SQLCMD mode must be enabled to successfully execute this script.';
        SET NOEXEC ON;
    END


GO
USE [master];


GO

IF (DB_ID(N'$(DatabaseName)') IS NOT NULL) 
BEGIN
    ALTER DATABASE [$(DatabaseName)]
    SET SINGLE_USER WITH ROLLBACK IMMEDIATE;
    DROP DATABASE [$(DatabaseName)];
END

GO
PRINT N'Creating $(DatabaseName)...'
GO
CREATE DATABASE [$(DatabaseName)]
    ON 
    PRIMARY(NAME = [$(DatabaseName)], FILENAME = N'$(DefaultDataPath)$(DefaultFilePrefix)_Primary.mdf')
    LOG ON (NAME = [$(DatabaseName)_log], FILENAME = N'$(DefaultLogPath)$(DefaultFilePrefix)_Primary.ldf') COLLATE Hebrew_CI_AI
GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ANSI_NULLS ON,
                ANSI_PADDING ON,
                ANSI_WARNINGS ON,
                ARITHABORT ON,
                CONCAT_NULL_YIELDS_NULL ON,
                NUMERIC_ROUNDABORT OFF,
                QUOTED_IDENTIFIER ON,
                ANSI_NULL_DEFAULT ON,
                CURSOR_DEFAULT LOCAL,
                RECOVERY FULL,
                CURSOR_CLOSE_ON_COMMIT OFF,
                AUTO_CREATE_STATISTICS ON,
                AUTO_SHRINK OFF,
                AUTO_UPDATE_STATISTICS ON,
                RECURSIVE_TRIGGERS OFF 
            WITH ROLLBACK IMMEDIATE;
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CLOSE OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET ALLOW_SNAPSHOT_ISOLATION OFF;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET READ_COMMITTED_SNAPSHOT OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_UPDATE_STATISTICS_ASYNC OFF,
                PAGE_VERIFY NONE,
                DATE_CORRELATION_OPTIMIZATION OFF,
                DISABLE_BROKER,
                PARAMETERIZATION SIMPLE,
                SUPPLEMENTAL_LOGGING OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET TRUSTWORTHY OFF,
        DB_CHAINING OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
IF IS_SRVROLEMEMBER(N'sysadmin') = 1
    BEGIN
        IF EXISTS (SELECT 1
                   FROM   [master].[dbo].[sysdatabases]
                   WHERE  [name] = N'$(DatabaseName)')
            BEGIN
                EXECUTE sp_executesql N'ALTER DATABASE [$(DatabaseName)]
    SET HONOR_BROKER_PRIORITY OFF 
    WITH ROLLBACK IMMEDIATE';
            END
    END
ELSE
    BEGIN
        PRINT N'The database settings cannot be modified. You must be a SysAdmin to apply these settings.';
    END


GO
ALTER DATABASE [$(DatabaseName)]
    SET TARGET_RECOVERY_TIME = 0 SECONDS 
    WITH ROLLBACK IMMEDIATE;


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET FILESTREAM(NON_TRANSACTED_ACCESS = OFF),
                CONTAINMENT = NONE 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET AUTO_CREATE_STATISTICS ON(INCREMENTAL = OFF),
                MEMORY_OPTIMIZED_ELEVATE_TO_SNAPSHOT = OFF,
                DELAYED_DURABILITY = DISABLED 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE (QUERY_CAPTURE_MODE = ALL, DATA_FLUSH_INTERVAL_SECONDS = 900, INTERVAL_LENGTH_MINUTES = 60, MAX_PLANS_PER_QUERY = 200, CLEANUP_POLICY = (STALE_QUERY_THRESHOLD_DAYS = 367), MAX_STORAGE_SIZE_MB = 100) 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE [$(DatabaseName)]
            SET QUERY_STORE = OFF 
            WITH ROLLBACK IMMEDIATE;
    END


GO
IF EXISTS (SELECT 1
           FROM   [master].[dbo].[sysdatabases]
           WHERE  [name] = N'$(DatabaseName)')
    BEGIN
        ALTER DATABASE SCOPED CONFIGURATION SET MAXDOP = 0;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET MAXDOP = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET LEGACY_CARDINALITY_ESTIMATION = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET LEGACY_CARDINALITY_ESTIMATION = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET PARAMETER_SNIFFING = ON;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET PARAMETER_SNIFFING = PRIMARY;
        ALTER DATABASE SCOPED CONFIGURATION SET QUERY_OPTIMIZER_HOTFIXES = OFF;
        ALTER DATABASE SCOPED CONFIGURATION FOR SECONDARY SET QUERY_OPTIMIZER_HOTFIXES = PRIMARY;
    END


GO
USE [$(DatabaseName)];


GO
IF fulltextserviceproperty(N'IsFulltextInstalled') = 1
    EXECUTE sp_fulltext_database 'enable';


GO
/*
 Pre-Deployment Script Template							
--------------------------------------------------------------------------------------
 This file contains SQL statements that will be executed before the build script.	
 Use SQLCMD syntax to include a file in the pre-deployment script.			
 Example:      :r .\myfile.sql								
 Use SQLCMD syntax to reference a variable in the pre-deployment script.		
 Example:      :setvar TableName MyTable							
               SELECT * FROM [$(TableName)]					
--------------------------------------------------------------------------------------
*/
if exists (select * from sys.servers where name='Priority')
	exec sp_dropserver 'Priority', 'droplogins'; 

EXEC master.dbo.sp_addlinkedserver
@server = N'Priority',
@srvproduct=N'',
@provider=N'SQLNCLI',
@datasrc=N'Priority'
GO

EXEC master.dbo.sp_addlinkedsrvlogin
@rmtsrvname=N'Priority',
@useself=N'False',
@locallogin=NULL,
@rmtuser=N'oridoner',
@rmtpassword='oridoner'
GO





GO

GO
PRINT N'Creating [ADMN]...';


GO
CREATE SCHEMA [ADMN]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ENG]...';


GO
CREATE SCHEMA [ENG]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ERP]...';


GO
CREATE SCHEMA [ERP]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ETL]...';


GO
CREATE SCHEMA [ETL]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [EXTR]...';


GO
CREATE SCHEMA [EXTR]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [GEN]...';


GO
CREATE SCHEMA [GEN]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [LOAD]...';


GO
CREATE SCHEMA [LOAD]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [MKT]...';


GO
CREATE SCHEMA [MKT]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [OPR]...';


GO
CREATE SCHEMA [OPR]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [TEST]...';


GO
CREATE SCHEMA [TEST]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [TRNS]...';


GO
CREATE SCHEMA [TRNS]
    AUTHORIZATION [dbo];


GO
PRINT N'Creating [ENG].[Parts]...';


GO
CREATE TABLE [ENG].[Parts] (
    [PartID]           INT          NOT NULL,
    [Part]             VARCHAR (22) NOT NULL,
    [PartHebDes]       VARCHAR (48) NOT NULL,
    [PartEngDes]       VARCHAR (48) NOT NULL,
    [PartType]         CHAR (1)     NOT NULL,
    [ProcessID]        INT          NOT NULL,
    [Process]          VARCHAR (6)  NOT NULL,
    [FamilyID]         INT          NOT NULL,
    [Family]           VARCHAR (8)  NOT NULL,
    [FamilyDes]        VARCHAR (32) NOT NULL,
    [PartStatusID]     INT          NOT NULL,
    [PartStatus]       VARCHAR (12) NOT NULL,
    [Symbol]           VARCHAR (20) NULL,
    [Package]          VARCHAR (20) NULL,
    [Parameter08]      VARCHAR (12) NULL,
    [Parameter10]      VARCHAR (12) NULL,
    [Parameter19]      VARCHAR (12) NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    CONSTRAINT [pk_ENG_Part] PRIMARY KEY CLUSTERED ([PartID] ASC)
);


GO
PRINT N'Creating [ENG].[PartAct]...';


GO
CREATE TABLE [ENG].[PartAct] (
    [PartActID]       INT          IDENTITY (10000, 1) NOT NULL,
    [PartActBin]      AS           (CONVERT ([hierarchyid], ('/' + CONVERT (VARCHAR (10), [PartActID])) + '/')) PERSISTED,
    [ProcessID]       INT          NULL,
    [PartID]          INT          NOT NULL,
    [Part]            VARCHAR (22) NOT NULL,
    [PartType]        VARCHAR (1)  NULL,
    [PartIsRoot]      BIT          NULL,
    [PartIsActive]    BIT          NULL,
    [ActID]           INT          NULL,
    [Act]             VARCHAR (10) NULL,
    [ActPos]          INT          NULL,
    [PrevActID]       INT          NULL,
    [NextActID]       INT          NULL,
    [ActIsLast]       BIT          NULL,
    [ActDays]         INT          NULL,
    [WorkCenterID]    INT          NULL,
    [WorkCenter]      VARCHAR (6)  NULL,
    [stdTimeEmployee] FLOAT (53)   NULL,
    [stdTimeMachine]  FLOAT (53)   NULL,
    [Branch]          VARCHAR (10) NULL,
    [BranchLevel]     VARCHAR (15) NULL,
    [IsBranchRoot]    BIT          NULL,
    [IsBranchEdge]    BIT          NULL,
    [DateTimeStamp]   DATETIME     NULL,
    [Source]          VARCHAR (10) NULL,
    CONSTRAINT [pk_ENG_PartAct] PRIMARY KEY CLUSTERED ([PartActID] ASC)
);


GO
PRINT N'Creating [ENG].[PartAct].[idx_ENG_PartPreAct]...';


GO
CREATE NONCLUSTERED INDEX [idx_ENG_PartPreAct]
    ON [ENG].[PartAct]([PartID] ASC, [PrevActID] ASC)
    INCLUDE([PartActID], [Act], [ActID], [ActPos], [ActIsLast]);


GO
PRINT N'Creating [ENG].[PartAct].[idx_ENG_PartIsRoot]...';


GO
CREATE NONCLUSTERED INDEX [idx_ENG_PartIsRoot]
    ON [ENG].[PartAct]([PartID] ASC, [IsBranchRoot] ASC)
    INCLUDE([PartActID], [ActID], [Part], [Act]);


GO
PRINT N'Creating [ENG].[PartAct].[idx_ENG_PartActPos]...';


GO
CREATE NONCLUSTERED INDEX [idx_ENG_PartActPos]
    ON [ENG].[PartAct]([PartID] ASC, [ActPos] ASC)
    INCLUDE([PartActID], [Part], [ActID], [Act], [ActIsLast]);


GO
PRINT N'Creating [ENG].[PartAct].[idx_ENG_PartActIsLast]...';


GO
CREATE NONCLUSTERED INDEX [idx_ENG_PartActIsLast]
    ON [ENG].[PartAct]([PartID] ASC, [ActIsLast] ASC)
    INCLUDE([PartActID], [ActID], [Act]);


GO
PRINT N'Creating [ENG].[PartAct].[idx_ENG_PartActBin]...';


GO
CREATE NONCLUSTERED INDEX [idx_ENG_PartActBin]
    ON [ENG].[PartAct]([PartActBin] ASC)
    INCLUDE([PartActID], [Part], [ActID], [Act], [ActIsLast]);


GO
PRINT N'Creating [EXTR].[SERIAL]...';


GO
CREATE TABLE [EXTR].[SERIAL] (
    [RowID]            INT          IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME     NOT NULL,
    [RowExpiryDate]    DATETIME     NOT NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    [SERIAL]           INT          NOT NULL,
    [UDATE]            INT          NOT NULL,
    [SERIALNAME]       VARCHAR (22) NOT NULL,
    [SERIALDES]        VARCHAR (48) NOT NULL,
    [SERIALSTATUS]     INT          NOT NULL,
    [SERIALSTATUSDES]  VARCHAR (12) NOT NULL,
    [PSDATE]           INT          NOT NULL,
    [PART]             INT          NOT NULL,
    [CLOSED]           CHAR (1)     NOT NULL,
    [PEDATE]           INT          NOT NULL,
    [QUANT]            BIGINT       NOT NULL,
    [CURDATE]          INT          NOT NULL,
    [CLOSEDATE]        INT          NOT NULL,
    [T$USER]           INT          NOT NULL,
    CONSTRAINT [pk_EXTR_SERIAL] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[SERIAL].[idx_SERIAL_ExpiryDate]...';


GO
CREATE NONCLUSTERED INDEX [idx_SERIAL_ExpiryDate]
    ON [EXTR].[SERIAL]([RowExpiryDate] ASC)
    INCLUDE([RowID], [RowEffectiveDate], [SERIAL], [UDATE], [SERIALNAME], [SERIALDES], [SERIALSTATUS], [SERIALSTATUSDES], [PSDATE], [PART], [CLOSED], [PEDATE], [QUANT], [CURDATE], [CLOSEDATE], [T$USER]);


GO
PRINT N'Creating [EXTR].[SERIAL].[idx_SERIAL_UDATE]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_SERIAL_UDATE]
    ON [EXTR].[SERIAL]([UDATE] ASC, [SERIAL] ASC)
    INCLUDE([RowID], [RowEffectiveDate], [SERIALNAME], [SERIALDES], [SERIALSTATUS], [SERIALSTATUSDES], [PSDATE], [PART], [CLOSED], [PEDATE], [QUANT], [CURDATE], [CLOSEDATE], [T$USER]);


GO
PRINT N'Creating [EXTR].[ALINE]...';


GO
CREATE TABLE [EXTR].[ALINE] (
    [RowID]            INT          IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME     NOT NULL,
    [RowExpiryDate]    DATETIME     NOT NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    [AL]               INT          NOT NULL,
    [UDATE]            INT          NOT NULL,
    [FORM]             INT          NOT NULL,
    [FORMNAME]         VARCHAR (16) NULL,
    [SERIAL]           INT          NOT NULL,
    [PART]             INT          NOT NULL,
    [ACT]              INT          NOT NULL,
    [SERCANCEL]        CHAR (1)     NOT NULL,
    [CURDATE]          INT          NOT NULL,
    [QUANT]            BIGINT       NOT NULL,
    [SQUANT]           BIGINT       NOT NULL,
    [EMPEDATE]         INT          NULL,
    [EMPSDATE]         INT          NULL,
    [EMPASPAN]         INT          NULL,
    [WORKC]            INT          NOT NULL,
    [SERN]             INT          NULL,
    CONSTRAINT [pk_EXTR_ALINE] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[ALINE].[idx_ALINE_UDATE]...';


GO
CREATE NONCLUSTERED INDEX [idx_ALINE_UDATE]
    ON [EXTR].[ALINE]([UDATE] ASC)
    INCLUDE([AL], [FORM], [FORMNAME], [SERIAL], [PART], [ACT], [SERCANCEL], [CURDATE], [QUANT], [SQUANT], [EMPEDATE], [EMPSDATE], [EMPASPAN], [WORKC], [SERN]);


GO
PRINT N'Creating [EXTR].[ALINE].[idx_ALINE_ExpiryDate]...';


GO
CREATE NONCLUSTERED INDEX [idx_ALINE_ExpiryDate]
    ON [EXTR].[ALINE]([RowExpiryDate] ASC)
    INCLUDE([RowID], [AL], [UDATE], [FORM], [FORMNAME], [SERIAL], [PART], [ACT], [SERCANCEL], [CURDATE], [QUANT], [SQUANT], [EMPEDATE], [EMPSDATE], [EMPASPAN], [WORKC], [SERN]);


GO
PRINT N'Creating [EXTR].[ALINE].[idx_ALINE_AL]...';


GO
CREATE NONCLUSTERED INDEX [idx_ALINE_AL]
    ON [EXTR].[ALINE]([AL] ASC, [UDATE] ASC)
    INCLUDE([RowID], [RowEffectiveDate], [RowExpiryDate], [RowDateTimeStamp], [FORM], [FORMNAME], [SERIAL], [PART], [ACT], [SERCANCEL], [CURDATE], [QUANT], [SQUANT], [EMPEDATE], [EMPSDATE], [EMPASPAN], [WORKC], [SERN]);


GO
PRINT N'Creating [EXTR].[PART]...';


GO
CREATE TABLE [EXTR].[PART] (
    [RowID]            INT          IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME     NOT NULL,
    [RowExpiryDate]    DATETIME     NOT NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    [PART]             INT          NOT NULL,
    [UDATE]            INT          NOT NULL,
    [PARTNAME]         VARCHAR (22) NOT NULL,
    [PARTDES]          VARCHAR (48) NOT NULL,
    [EPARTDES]         VARCHAR (48) NOT NULL,
    [TYPE]             CHAR (1)     NOT NULL,
    [T$PROC]           INT          NOT NULL,
    [PROCNAME]         VARCHAR (6)  NOT NULL,
    [FAMILY]           INT          NOT NULL,
    [FAMILYNAME]       VARCHAR (8)  NOT NULL,
    [FAMILYDES]        VARCHAR (32) NOT NULL,
    [PARTSTAT]         INT          NOT NULL,
    [STATDES]          VARCHAR (12) NOT NULL,
    [SPEC3]            VARCHAR (20) NULL,
    [SPEC4]            VARCHAR (20) NULL,
    [SPEC8]            VARCHAR (12) NULL,
    [SPEC10]           VARCHAR (12) NULL,
    [SPEC19]           VARCHAR (12) NULL,
    [test]             NCHAR (10)   NULL,
    CONSTRAINT [pk_EXTR_PART] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[PART].[idx_PART_ExpiryDate]...';


GO
CREATE NONCLUSTERED INDEX [idx_PART_ExpiryDate]
    ON [EXTR].[PART]([RowExpiryDate] ASC)
    INCLUDE([PART], [PARTNAME], [PARTDES], [TYPE], [T$PROC], [PROCNAME], [FAMILY], [FAMILYNAME], [FAMILYDES], [PARTSTAT], [STATDES], [SPEC8], [SPEC10]);


GO
PRINT N'Creating [EXTR].[PART].[idx_PART_UDATE]...';


GO
CREATE NONCLUSTERED INDEX [idx_PART_UDATE]
    ON [EXTR].[PART]([PART] ASC, [UDATE] ASC)
    INCLUDE([PARTNAME], [PARTDES], [TYPE], [T$PROC], [PROCNAME], [FAMILY], [FAMILYNAME], [FAMILYDES], [PARTSTAT], [STATDES], [SPEC8], [SPEC10]);


GO
PRINT N'Creating [EXTR].[CUSTOMERS]...';


GO
CREATE TABLE [EXTR].[CUSTOMERS] (
    [RowID]            INT          IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME     NOT NULL,
    [RowExpiryDate]    DATETIME     NOT NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    [CUST]             INT          NOT NULL,
    [UDATE]            INT          NOT NULL,
    [CUSTNAME]         VARCHAR (16) NOT NULL,
    [CUSTDES]          VARCHAR (48) NOT NULL,
    [CUSTSTAT]         INT          NOT NULL,
    [STATDES]          VARCHAR (12) NOT NULL,
    [COUNTRY]          INT          NULL,
    [COUNTRYNAME]      VARCHAR (18) NULL,
    [CURRENCY]         INT          NOT NULL,
    [CODE]             VARCHAR (3)  NOT NULL,
    [CTYPE]            INT          NOT NULL,
    [IVTYPE]           CHAR (1)     NOT NULL,
    [SPEC1]            VARCHAR (32) NULL,
    [SPEC2]            VARCHAR (32) NULL,
    [SPEC3]            VARCHAR (32) NULL,
    [SPEC6]            VARCHAR (32) NULL,
    [SPEC9]            VARCHAR (32) NULL,
    CONSTRAINT [pk_EXTR_CUSTOMERS] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[PROCACT]...';


GO
CREATE TABLE [EXTR].[PROCACT] (
    [RowID]            INT      IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME NOT NULL,
    [RowExpiryDate]    DATETIME NOT NULL,
    [T$PROC]           INT      NOT NULL,
    [ACT]              INT      NOT NULL,
    [POS]              INT      NOT NULL,
    [ActPos]           INT      NULL,
    CONSTRAINT [pk_EXTR_PROCACT] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[ORDERITEMS]...';


GO
CREATE TABLE [EXTR].[ORDERITEMS] (
    [RowID]            INT          IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME     NOT NULL,
    [RowExpiryDate]    DATETIME     NOT NULL,
    [RowDateTimeStamp] DATETIME     NOT NULL,
    [ORDI]             INT          NOT NULL,
    [UDATE]            INT          NOT NULL,
    [ORD]              INT          NOT NULL,
    [ORDNAME]          VARCHAR (16) NOT NULL,
    [ORDSTATUS]        INT          NOT NULL,
    [ORDSTATUSDES]     VARCHAR (12) NOT NULL,
    [CUST]             INT          NOT NULL,
    [PART]             INT          NOT NULL,
    [QUANT]            BIGINT       NOT NULL,
    [ABALANCE]         BIGINT       NOT NULL,
    [DUEDATE]          INT          NOT NULL,
    [T$USER]           INT          NOT NULL,
    [CLOSED]           CHAR (1)     NOT NULL,
    CONSTRAINT [pk_EXTR_ORDERITEMS] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[ORDERITEMS].[idx_ERP_ORDERITEMS_ExpiryDate]...';


GO
CREATE NONCLUSTERED INDEX [idx_ERP_ORDERITEMS_ExpiryDate]
    ON [EXTR].[ORDERITEMS]([RowExpiryDate] ASC)
    INCLUDE([RowID], [RowEffectiveDate], [ORDI], [UDATE], [ORD], [ORDSTATUS], [ORDSTATUSDES], [CUST], [PART], [QUANT], [ABALANCE], [DUEDATE], [T$USER], [CLOSED]);


GO
PRINT N'Creating [EXTR].[PARTARC]...';


GO
CREATE TABLE [EXTR].[PARTARC] (
    [RowID]            INT        IDENTITY (10000000, 1) NOT NULL,
    [RowEffectiveDate] DATETIME   NOT NULL,
    [RowExpiryDate]    DATETIME   NOT NULL,
    [PART]             INT        NOT NULL,
    [ACT]              INT        NOT NULL,
    [SON]              INT        NOT NULL,
    [COEF]             FLOAT (53) NULL,
    CONSTRAINT [pk_EXTR_PARTARC] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [EXTR].[PARTARC].[idx_EXTR_PART_SON]...';


GO
CREATE NONCLUSTERED INDEX [idx_EXTR_PART_SON]
    ON [EXTR].[PARTARC]([PART] ASC, [ACT] ASC, [SON] ASC)
    INCLUDE([COEF]);


GO
PRINT N'Creating [GEN].[Calendar]...';


GO
CREATE TABLE [GEN].[Calendar] (
    [DateInt]  INT          NOT NULL,
    [DateStr]  VARCHAR (20) NOT NULL,
    [Year]     INT          NOT NULL,
    [YrNN]     INT          NOT NULL,
    [YYYYMM]   INT          NOT NULL,
    [Month]    INT          NOT NULL,
    [Day]      INT          NOT NULL,
    [WkDNo]    INT          NULL,
    [workDay]  INT          NOT NULL,
    [WkDName]  NCHAR (9)    NULL,
    [WkDName2] NCHAR (2)    NULL,
    [WkDName3] NCHAR (3)    NULL,
    [JulDay]   INT          NULL,
    [Week]     INT          NULL,
    [WkNo]     INT          NULL,
    [Qtr]      INT          NULL,
    [Last]     INT          NULL,
    [LdOfMo]   INT          NULL,
    [LDtOfMo]  DATE         NOT NULL,
    CONSTRAINT [pk_Calendar] PRIMARY KEY CLUSTERED ([DateInt] ASC),
    CONSTRAINT [Cal_ix0] UNIQUE NONCLUSTERED ([DateStr] ASC),
    CONSTRAINT [Cal_ix1] UNIQUE NONCLUSTERED ([Year] ASC, [Month] ASC, [Day] ASC),
    CONSTRAINT [Cal_ix2] UNIQUE NONCLUSTERED ([YYYYMM] ASC, [Day] ASC)
);


GO
PRINT N'Creating [GEN].[Calendar].[idx_YearWeek]...';


GO
CREATE NONCLUSTERED INDEX [idx_YearWeek]
    ON [GEN].[Calendar]([Year] ASC, [Week] ASC)
    INCLUDE([DateInt], [Month], [WkDNo], [DateStr], [workDay]);


GO
PRINT N'Creating [MKT].[Clients]...';


GO
CREATE TABLE [MKT].[Clients] (
    [ClientID]       INT          NOT NULL,
    [Client]         VARCHAR (16) NOT NULL,
    [ClientDes]      VARCHAR (48) NOT NULL,
    [ClientPriority] INT          NULL,
    [ClientStatusID] INT          NOT NULL,
    [ClientStatus]   VARCHAR (12) NOT NULL,
    [CountryID]      INT          NULL,
    [Country]        VARCHAR (18) NULL,
    [CurrencyID]     INT          NOT NULL,
    [Currency]       VARCHAR (3)  NOT NULL,
    [Parameter01]    VARCHAR (32) NULL,
    [Parameter02]    VARCHAR (32) NULL,
    [Parameter03]    VARCHAR (32) NULL,
    [Parameter06]    VARCHAR (32) NULL,
    [Parameter09]    VARCHAR (32) NULL,
    [DateTimeStamp]  DATETIME     NOT NULL,
    CONSTRAINT [pk_Clients] PRIMARY KEY CLUSTERED ([ClientID] ASC)
);


GO
PRINT N'Creating [MKT].[Forecasts]...';


GO
CREATE TABLE [MKT].[Forecasts] (
    [ForecastID]          INT      IDENTITY (100000, 1) NOT NULL,
    [ForecastRowID]       INT      NOT NULL,
    [ForecastYear]        INT      NOT NULL,
    [ForecastMonth]       INT      NOT NULL,
    [PartID]              INT      NOT NULL,
    [ForecastQuant]       INT      NULL,
    [ForecastIsOpen]      BIT      NULL,
    [ForecastUpdatedDate] DATETIME NULL,
    [DateTimeStamp]       DATETIME NOT NULL,
    CONSTRAINT [pk_Forecasts] PRIMARY KEY CLUSTERED ([ForecastID] ASC)
);


GO
PRINT N'Creating [MKT].[Forecasts].[idx_Forecast1]...';


GO
CREATE NONCLUSTERED INDEX [idx_Forecast1]
    ON [MKT].[Forecasts]([ForecastIsOpen] ASC, [ForecastYear] ASC, [ForecastMonth] ASC, [PartID] ASC)
    INCLUDE([ForecastID], [ForecastRowID], [ForecastQuant], [ForecastUpdatedDate]);


GO
PRINT N'Creating [MKT].[Forecasts].[idx_Forecast]...';


GO
CREATE NONCLUSTERED INDEX [idx_Forecast]
    ON [MKT].[Forecasts]([ForecastYear] ASC, [ForecastMonth] ASC, [PartID] ASC) WHERE ForecastIsOpen=1;


GO
PRINT N'Creating [MKT].[Forecasts].[idx_ForecastIsOpen]...';


GO
CREATE NONCLUSTERED INDEX [idx_ForecastIsOpen]
    ON [MKT].[Forecasts]([ForecastIsOpen] ASC)
    INCLUDE([ForecastID], [ForecastRowID], [ForecastYear], [ForecastMonth], [PartID], [ForecastQuant], [ForecastUpdatedDate]);


GO
PRINT N'Creating [MKT].[Forecasts].[idx_Forecasts]...';


GO
CREATE UNIQUE NONCLUSTERED INDEX [idx_Forecasts]
    ON [MKT].[Forecasts]([ForecastYear] ASC, [ForecastMonth] ASC, [PartID] ASC);


GO
PRINT N'Creating [MKT].[ClientOrders]...';


GO
CREATE TABLE [MKT].[ClientOrders] (
    [RowID]                INT          IDENTITY (100000, 1) NOT NULL,
    [ClientOrderRowID]     INT          NOT NULL,
    [ClientOrderID]        INT          NOT NULL,
    [ClientOrder]          VARCHAR (16) NOT NULL,
    [ClientOrderStatusID]  INT          NOT NULL,
    [ClientOrderStatus]    VARCHAR (12) NOT NULL,
    [ClientID]             INT          NOT NULL,
    [PartID]               INT          NOT NULL,
    [ClientOrderQuant]     INT          NULL,
    [ClientOrderBalance]   INT          NULL,
    [ClientOrderDueDateID] INT          NULL,
    [UserID]               INT          NULL,
    [ClientOrderIsOpen]    BIT          NULL,
    [DateTimeStamp]        DATETIME     NOT NULL,
    CONSTRAINT [pk_ClientOrders] PRIMARY KEY CLUSTERED ([RowID] ASC)
);


GO
PRINT N'Creating [MKT].[ClientOrders].[idx_ActiveClientOrders]...';


GO
CREATE NONCLUSTERED INDEX [idx_ActiveClientOrders]
    ON [MKT].[ClientOrders]([ClientOrderIsOpen] ASC, [ClientID] ASC)
    INCLUDE([ClientOrderID], [ClientOrder], [ClientOrderStatusID], [ClientOrderStatus], [PartID], [ClientOrderBalance], [ClientOrderDueDateID]);


GO
PRINT N'Creating [OPR].[WorkOrders]...';


GO
CREATE TABLE [OPR].[WorkOrders] (
    [WrkOrdID]          INT          NOT NULL,
    [WrkOrd]            VARCHAR (22) NULL,
    [PartID]            INT          NULL,
    [WrkOrdStatID]      INT          NULL,
    [WrkOrdStat]        VARCHAR (12) NULL,
    [WrkOrdQuant]       INT          NULL,
    [WrkOrdClosedDate]  DATETIME     NULL,
    [WrkOrdCreatedDate] DATETIME     NULL,
    [WrkOrdStartDate]   DATE         NULL,
    [WrkOrdEndDate]     DATE         NULL,
    [WrkOrdIsActive]    BIT          NULL,
    [DateTimeStamp]     DATETIME     NULL,
    CONSTRAINT [pk_OPR_WorkOrders] PRIMARY KEY CLUSTERED ([WrkOrdID] ASC)
);


GO
PRINT N'Creating [OPR].[Production]...';


GO
CREATE TABLE [OPR].[Production] (
    [ProductionRowID]     INT          NOT NULL,
    [ProductionFormID]    INT          NOT NULL,
    [ProductionForm]      VARCHAR (16) NOT NULL,
    [WrkOrdID]            INT          NOT NULL,
    [PartID]              INT          NOT NULL,
    [ActID]               INT          NOT NULL,
    [ActIsLast]           BIT          NOT NULL,
    [ProductionPass]      INT          NOT NULL,
    [ProductionFail]      INT          NOT NULL,
    [ProductionDateID]    INT          NOT NULL,
    [ProductionDate]      DATE         NOT NULL,
    [ProductionStartDate] DATE         NULL,
    [ProductionEndDate]   DATE         NULL,
    [ReportingDateTime]   DATETIME     NOT NULL,
    [ProdTime]            INT          NOT NULL,
    [WorkCenterID]        INT          NOT NULL,
    [UserID]              INT          NOT NULL,
    [DateTimeStamp]       DATETIME     NOT NULL,
    CONSTRAINT [pk_ProductionReport] PRIMARY KEY CLUSTERED ([ProductionRowID] ASC)
);


GO
PRINT N'Creating [OPR].[Production].[idx_Production_ActISLast]...';


GO
CREATE NONCLUSTERED INDEX [idx_Production_ActISLast]
    ON [OPR].[Production]([ActIsLast] ASC)
    INCLUDE([ProductionRowID], [ProductionFormID], [ProductionForm], [WrkOrdID], [PartID], [ActID], [ProductionPass], [ProductionFail], [ProductionDateID], [ProductionDate], [ProdTime], [WorkCenterID]);


GO
PRINT N'Creating [TRNS].[PartActHierarchy]...';


GO
CREATE TABLE [TRNS].[PartActHierarchy] (
    [PartActID]      INT                 NULL,
    [PartActBinPath] [sys].[hierarchyid] NOT NULL,
    [PartActLev]     AS                  PartActBinPath.GetLevel() PERSISTED,
    [PartActBinRoot] [sys].[hierarchyid] NOT NULL,
    [PartActCoef]    FLOAT (53)          NULL,
    [ActDays]        INT                 NULL,
    CONSTRAINT [pk_PartActBom] PRIMARY KEY CLUSTERED ([PartActBinPath] ASC)
);


GO
PRINT N'Creating [TRNS].[PartActHierarchy].[idx_SonPartActID]...';


GO
CREATE NONCLUSTERED INDEX [idx_SonPartActID]
    ON [TRNS].[PartActHierarchy]([PartActID] ASC)
    INCLUDE([PartActLev], [PartActCoef], [ActDays], [PartActBinRoot]);


GO
PRINT N'Creating [TRNS].[PartActHierarchy].[idx_PartActBinRoot]...';


GO
CREATE NONCLUSTERED INDEX [idx_PartActBinRoot]
    ON [TRNS].[PartActHierarchy]([PartActBinRoot] ASC)
    INCLUDE([PartActID], [PartActLev], [PartActCoef], [ActDays]);


GO
PRINT N'Creating [TRNS].[PartActAdjacency]...';


GO
CREATE TABLE [TRNS].[PartActAdjacency] (
    [ParentPartActID] INT        NULL,
    [SonPartActID]    INT        NULL,
    [SonRowNum]       INT        NULL,
    [SonPartActCoef]  FLOAT (53) NULL,
    [SonActDays]      INT        NULL
);


GO
PRINT N'Creating [TRNS].[PartAct]...';


GO
CREATE TABLE [TRNS].[PartAct] (
    [PartActID]       INT          IDENTITY (10000, 1) NOT NULL,
    [PartActBin]      AS           (CONVERT ([hierarchyid], ('/' + CONVERT (VARCHAR (10), [PartActID])) + '/')) PERSISTED,
    [PartID]          INT          NOT NULL,
    [Part]            VARCHAR (22) NULL,
    [PartType]        VARCHAR (1)  NULL,
    [PartIsRoot]      BIT          NULL,
    [PartIsActive]    BIT          NULL,
    [ProcessID]       INT          NOT NULL,
    [ActID]           INT          NOT NULL,
    [Act]             VARCHAR (10) NULL,
    [ActPos]          INT          NULL,
    [PrevActID]       INT          NULL,
    [NextActID]       INT          NULL,
    [ActIsLast]       BIT          NULL,
    [ActDays]         INT          NULL,
    [WorkCenterID]    INT          NULL,
    [WorkCenter]      VARCHAR (6)  NULL,
    [stdTimeEmployee] FLOAT (53)   NULL,
    [stdTimeMachine]  FLOAT (53)   NULL,
    CONSTRAINT [pk_TRNS_PartAct] PRIMARY KEY CLUSTERED ([PartActID] ASC)
);


GO
PRINT N'Creating [TRNS].[PROCACT]...';


GO
CREATE TABLE [TRNS].[PROCACT] (
    [PART]   INT          NOT NULL,
    [T$PROC] INT          NOT NULL,
    [Source] VARCHAR (10) NULL,
    CONSTRAINT [pk_EXTR_PartProcess] PRIMARY KEY CLUSTERED ([PART] ASC)
);


GO
PRINT N'Creating [TRNS].[PartActAssembly]...';


GO
CREATE TABLE [TRNS].[PartActAssembly] (
    [AssemblyID]      INT                 IDENTITY (10000, 1) NOT NULL,
    [PartActID]       INT                 NOT NULL,
    [AssemblyPartID]  INT                 NOT NULL,
    [AssemblyBinPath] [sys].[hierarchyid] NULL,
    CONSTRAINT [pk_PartActAssembly] PRIMARY KEY CLUSTERED ([AssemblyID] ASC)
);


GO
PRINT N'Creating [TRNS].[PartActAssembly].[idx_PartActAssembly]...';


GO
CREATE NONCLUSTERED INDEX [idx_PartActAssembly]
    ON [TRNS].[PartActAssembly]([PartActID] ASC, [AssemblyPartID] ASC);


GO
PRINT N'Creating [TRNS].[PARTARC]...';


GO
CREATE TABLE [TRNS].[PARTARC] (
    [RowChange] VARCHAR (10) NULL,
    [PART]      INT          NOT NULL,
    [ACT]       INT          NOT NULL,
    [SON]       INT          NOT NULL,
    [COEF]      FLOAT (53)   NULL
);


GO
PRINT N'Creating [TRNS].[PARTARC].[idx_TRNS_PART_SON]...';


GO
CREATE NONCLUSTERED INDEX [idx_TRNS_PART_SON]
    ON [TRNS].[PARTARC]([PART] ASC, [ACT] ASC, [SON] ASC)
    INCLUDE([COEF]);


GO
PRINT N'Creating unnamed constraint on [ENG].[PartAct]...';


GO
ALTER TABLE [ENG].[PartAct]
    ADD DEFAULT (0) FOR [IsBranchRoot];


GO
PRINT N'Creating unnamed constraint on [ENG].[PartAct]...';


GO
ALTER TABLE [ENG].[PartAct]
    ADD DEFAULT (0) FOR [IsBranchEdge];


GO
PRINT N'Creating [EXTR].[PART_AfterInsertTrigger]...';


GO
CREATE TRIGGER EXTR.PART_AfterInsertTrigger ON EXTR.PART
--Because UDATE allways increases EXTR.PART allways grows (only Inserts, no updates) 
AFTER INSERT
AS
	MERGE ENG.Parts		AS Target
	USING	(
			SELECT	T1.PART			,
					T1.PARTNAME		,
					T1.PARTDES		,
					T1.EPARTDES		,
					T1.TYPE			,
					T1.T$PROC		,
					T1.PROCNAME		,
					T1.FAMILY		,
					T1.FAMILYNAME	,
					T1.FAMILYDES	,
					T1.PARTSTAT		,
					T1.STATDES		,
					T1.SPEC3		,
					T1.SPEC4		,
					T1.SPEC8		,
					T1.SPEC10		,
					T1.SPEC19	
			FROM inserted AS T1
			)						AS Source
	ON (Target.PartID=Source.PART)
	WHEN NOT MATCHED BY Target THEN
	INSERT	(
				 PartID
				,Part
				,PartHebDes
				,PartEngDes
				,PartType
				,ProcessID
				,Process
				,FamilyID
				,Family
				,FamilyDes
				,PartStatusID
				,PartStatus
				,Symbol
				,Package
				,Parameter08
				,Parameter10
				,Parameter19
				,RowDateTimeStamp
			)
	VALUES	(
				 Source.PART			
				,Source.PARTNAME		
				,Source.PARTDES	
				,Source.EPARTDES		
				,Source.TYPE			
				,Source.T$PROC		
				,Source.PROCNAME		
				,Source.FAMILY		
				,Source.FAMILYNAME	
				,Source.FAMILYDES	
				,Source.PARTSTAT		
				,Source.STATDES		
				,Source.SPEC3		
				,Source.SPEC4		
				,Source.SPEC8		
				,Source.SPEC10		
				,Source.SPEC19	
				,GETDATE()
			)
	WHEN MATCHED THEN
	UPDATE SET	 Target.PartID		= Source.PART			
				,Target.Part		= Source.PARTNAME		
				,Target.PartHebDes	= Source.PARTDES
				,Target.PartEngDes	= Source.EPARTDES	
				,Target.PartType	= Source.TYPE			
				,Target.ProcessID	= Source.T$PROC		
				,Target.Process		= Source.PROCNAME		
				,Target.FamilyID	= Source.FAMILY		
				,Target.Family		= Source.FAMILYNAME	
				,Target.FamilyDes	= Source.FAMILYDES	
				,Target.PartStatusID= Source.PARTSTAT		
				,Target.PartStatus	= Source.STATDES		
				,Target.Symbol		= Source.SPEC3		
				,Target.Package		= Source.SPEC4		
				,Target.Parameter08	= Source.SPEC8		
				,Target.Parameter10	= Source.SPEC10		
				,Target.Parameter19	= Source.SPEC19	
				,Target.RowDateTimeStamp= GETDATE()	;
GO
PRINT N'Creating [EXTR].[CUSTOMERS_AfterInsertTrigger]...';


GO
CREATE TRIGGER EXTR.CUSTOMERS_AfterInsertTrigger ON EXTR.CUSTOMERS 
AFTER INSERT
AS
BEGIN
MERGE MKT.Clients																	AS Target
USING	(
		SELECT	T1.CUST												AS ClientID			,								
				T1.CUSTNAME											AS Client			,
				IIF(T1.IVTYPE='F',REVERSE(T1.CUSTDES),T1.CUSTDES)	AS ClientDes		,
				(
					CASE
						WHEN		T1.CUST=841 
								OR  T1.CUST=911 
								OR  T1.CUST=1059 
								OR  T1.CUST=1242		THEN 1
						WHEN		T1.IVTYPE='F'		THEN 2
						WHEN		T1.CTYPE=13			THEN 4
						WHEN		T1.IVTYPE='C' 
								AND	T1.CTYPE<>13		THEN 3
						WHEN T1.CUST=937				THEN 5
					END
					)												AS ClientPriority	,
				T1.CUSTSTAT											AS ClientStatusID	,
				T1.STATDES											AS ClientStatus		,
				T1.COUNTRY											AS CountryID		,	
				T1.COUNTRYNAME										AS Country			,
				T1.CURRENCY											AS CurrencyID		,
				T1.CODE												AS Currency			,
				T1.SPEC1											AS Parameter01		,
				REVERSE(T1.SPEC2)									AS Parameter02		,
				REVERSE(T1.SPEC3)									AS Parameter03		,
				REVERSE(T1.SPEC6)									AS Parameter06		,
				T1.SPEC9											AS Parameter09	
		FROM	inserted											AS T1
		WHERE		T1.CUST<>940 
				AND T1.CUST<>1009 
				AND T1.CUST<>1141 
				AND T1.CUST>0 
				OR  T1.CUST=-4
		)																						AS Source
ON (Target.ClientID=Source.ClientID)
WHEN NOT MATCHED BY Target THEN
INSERT	(
			 ClientID
			,Client
			,ClientDes
			,ClientPriority
			,ClientStatusID
			,ClientStatus
			,CountryID
			,Country
			,CurrencyID
			,Currency
			,Parameter01
			,Parameter02
			,Parameter03
			,Parameter06
			,Parameter09
			,DateTimeStamp
		)
VALUES	(
			 Source.ClientID
			,Source.Client
			,Source.ClientDes
			,Source.ClientPriority
			,Source.ClientStatusID
			,Source.ClientStatus
			,Source.CountryID
			,Source.Country
			,Source.CurrencyID
			,Source.Currency
			,Source.Parameter01
			,Source.Parameter02
			,Source.Parameter03
			,Source.Parameter06
			,Source.Parameter09
			,GETDATE()
		)
WHEN MATCHED THEN
UPDATE SET 
					 Target.ClientID		= Source.ClientID 
					,Target.Client			= Source.Client 
					,Target.ClientDes		= Source.ClientDes
					,Target.ClientPriority	= Source.ClientPriority
					,Target.ClientStatusID	= Source.ClientStatusID
					,Target.ClientStatus	= Source.ClientStatus
					,Target.CountryID		= Source.CountryID
					,Target.Country			= Source.Country
					,Target.CurrencyID		= Source.CurrencyID
					,Target.Currency		= Source.Currency
					,Target.Parameter01		= Source.Parameter01
					,Target.Parameter02		= Source.Parameter02
					,Target.Parameter03		= Source.Parameter03
					,Target.Parameter06		= Source.Parameter06
					,Target.Parameter09		= Source.Parameter09
					,Target.DateTimeStamp	= GETDATE();
END;
GO
PRINT N'Creating [ERP].[calDateTime]...';


GO
CREATE FUNCTION ERP.calDateTime (@dateNum INT) 
RETURNS DATETIME
AS 
BEGIN
	DECLARE @prodDate DATETIME;
	SET @prodDate=IIF(@dateNum=0,NULL, DATEADD(MINUTE,DATEDIFF(MINUTE,0,DATEADD(SECOND,30,CONVERT(DATETIME,CAST(@dateNum AS DECIMAL)/1440+32141))),0));
	RETURN (@prodDate);
END;
GO
PRINT N'Creating [EXTR].[SERIAL_InsteadOfTrigger]...';


GO
CREATE TRIGGER [EXTR].[SERIAL_InsteadOfTrigger] ON EXTR.SERIAL 
INSTEAD OF INSERT
AS
BEGIN

--1.Update expiry date for exsisting rows (before insert)
WITH cte AS
(
	SELECT T1.* 
	FROM EXTR.SERIAL	AS T1
	JOIN inserted		AS T2 ON T2.SERIAL=T1.SERIAL
	CROSS APPLY
	(
		SELECT	RowID				AS ExpiredRowID		,
				T4.ExpiredRowDate
		FROM	EXTR.SERIAL 
		CROSS APPLY	
		(
			SELECT TOP(1)	UDATE	AS ExpiredRowDate
			FROM	EXTR.SERIAL 
			WHERE	SERIAL=T1.SERIAL 
			ORDER BY UDATE DESC
		)															AS T4
		WHERE	SERIAL=T1.SERIAL AND UDATE=T4.ExpiredRowDate
	)																AS T3
	WHERE T1.RowID=T3.ExpiredRowID
)
UPDATE EXTR.SERIAL 
SET RowExpiryDate=cte.RowDateTimeStamp,RowDateTimeStamp=GETDATE()
FROM cte 
WHERE EXTR.SERIAL.RowID=cte.RowID;

--2. Insert new rows: 
INSERT INTO EXTR.SERIAL (	
						 RowEffectiveDate	
						,RowExpiryDate
						,RowDateTimeStamp	
						,SERIAL
						,UDATE
						,SERIALNAME
						,SERIALDES
						,SERIALSTATUS
						,SERIALSTATUSDES
						,PSDATE
						,PART
						,CLOSED
						,PEDATE
						,QUANT
						,CURDATE
						,CLOSEDATE
						,T$USER
						)
SELECT	 ERP.calDateTime (T1.UDATE)
		,CAST ('99991231' AS DATETIME)
		,GETDATE()
		,T1.SERIAL
		,T1.UDATE
		,T1.SERIALNAME
		,T1.SERIALDES
		,T1.SERIALSTATUS
		,T1.SERIALSTATUSDES
		,T1.PSDATE
		,T1.PART
		,T1.CLOSED
		,T1.PEDATE
		,T1.QUANT
		,T1.CURDATE
		,T1.CLOSEDATE
		,T1.T$USER
FROM inserted		AS T1
END;
GO
PRINT N'Creating [EXTR].[ALINE_InsteadOfTrigger]...';


GO
CREATE TRIGGER EXTR.ALINE_InsteadOfTrigger ON EXTR.ALINE 
INSTEAD OF INSERT
AS
BEGIN
--1. Updating expiry date for existing rows before inserting new ones
WITH cte AS
(
	SELECT T1.* 
	FROM EXTR.ALINE	AS T1
	JOIN inserted	AS T2 ON T2.AL=T1.AL
	CROSS APPLY
	(
		SELECT TOP(1)	 RowID	AS ExpiredRowID
						,UDATE	AS ExpiredRowDate
		FROM	EXTR.ALINE 
		WHERE	AL=T1.AL 
		ORDER BY UDATE DESC
	)							AS T3
	WHERE T1.RowID=T3.ExpiredRowID
)
UPDATE EXTR.ALINE 
SET RowExpiryDate=cte.RowDateTimeStamp,RowDateTimeStamp=GETDATE()
FROM cte 
WHERE EXTR.ALINE.RowID=cte.RowID;

--2. Inserting new rows
INSERT INTO EXTR.ALINE	(
							RowEffectiveDate	,
							RowExpiryDate		,
							RowDateTimeStamp	,
							AL					,
							UDATE				,
							FORM				,
							FORMNAME			,
							SERIAL				,
							PART				,
							ACT					,
							SERCANCEL			,
							CURDATE				,
							QUANT				,
							SQUANT				,
							EMPEDATE			,
							EMPSDATE			,
							EMPASPAN			,
							WORKC				,
							SERN	
						) 
SELECT			ERP.calDateTime (T1.UDATE)		,
				CAST ('99991231' AS DATETIME)	,
				GETDATE()						,
			 	T1.AL							,
				T1.UDATE						,
				T1.FORM							,
				T1.FORMNAME						,
				T1.SERIAL						,
				T1.PART							,
				T1.ACT							,
				T1.SERCANCEL					,
				T1.CURDATE						,
				T1.QUANT						,
				T1.SQUANT						,
				T1.EMPEDATE						,
				T1.EMPSDATE						,
				T1.EMPASPAN						,
				T1.WORKC						,
				T1.SERN				
FROM inserted AS T1;
END;
GO
PRINT N'Creating [EXTR].[CUSTOMERS_InsteadOfTrigger]...';


GO
CREATE TRIGGER EXTR.CUSTOMERS_InsteadOfTrigger ON EXTR.CUSTOMERS 
INSTEAD OF INSERT
AS
BEGIN
--1. Update expiry date for exsisting rows
WITH cte AS
(
	SELECT T1.* 
	FROM EXTR.CUSTOMERS	AS T1
	JOIN inserted	AS T2 ON T2.CUST=T1.CUST
	CROSS APPLY
	(
		SELECT TOP(1)	 RowID	AS ExpiredRowID
						,UDATE	AS ExpiredRowDate
		FROM	EXTR.CUSTOMERS 
		WHERE	CUST=T1.CUST 
		ORDER BY UDATE DESC
	)							AS T3
	WHERE T1.RowID=T3.ExpiredRowID
)
UPDATE EXTR.CUSTOMERS 
SET RowExpiryDate=cte.RowDateTimeStamp,RowDateTimeStamp=GETDATE()
FROM cte 
WHERE EXTR.CUSTOMERS.RowID=cte.RowID;

--2.  Inserting new rows
INSERT	INTO EXTR.CUSTOMERS	(	
								 RowEffectiveDate
								,RowExpiryDate	
								,RowDateTimeStamp
								,CUST				
								,UDATE				
								,CUSTNAME			
								,CUSTDES			
								,CUSTSTAT			
								,STATDES			
								,COUNTRY			
								,COUNTRYNAME		
								,CURRENCY
								,CODE			
								,CTYPE				
								,IVTYPE				
								,SPEC1				
								,SPEC2				
								,SPEC3				
								,SPEC6	
								,SPEC9	
							)
SELECT				 ERP.calDateTime (T1.UDATE)
					,CAST ('99991231' AS DATETIME)
					,GETDATE()
					,T1.CUST				
					,T1.UDATE				
					,T1.CUSTNAME			
					,T1.CUSTDES			
					,T1.CUSTSTAT			
					,T1.STATDES			
					,T1.COUNTRY			
					,T1.COUNTRYNAME		
					,T1.CURRENCY
					,T1.CODE			
					,T1.CTYPE				
					,T1.IVTYPE				
					,T1.SPEC1				
					,T1.SPEC2				
					,T1.SPEC3				
					,T1.SPEC6	
					,T1.SPEC9	
FROM inserted AS T1;
END;
GO
PRINT N'Creating [EXTR].[ORDERITEMS_InsteadOfTrigger]...';


GO
CREATE TRIGGER EXTR.ORDERITEMS_InsteadOfTrigger ON EXTR.ORDERITEMS 
INSTEAD OF INSERT
AS
BEGIN
--1. Update expiry date for exsisting rows
WITH cte AS
(
	SELECT T1.* 
	FROM EXTR.ORDERITEMS	AS T1
	JOIN inserted			AS T2 ON T2.ORDI=T1.ORDI
	CROSS APPLY
	(
		SELECT TOP(1)	 RowID	AS ExpiredRowID
						,UDATE	AS ExpiredRowDate
		FROM	EXTR.ORDERITEMS 
		WHERE	ORDI=T1.ORDI 
		ORDER BY UDATE DESC
	)							AS T3
	WHERE T1.RowID=T3.ExpiredRowID
)
UPDATE EXTR.ORDERITEMS 
SET RowExpiryDate=cte.RowDateTimeStamp,RowDateTimeStamp=GETDATE()
FROM cte 
WHERE EXTR.ORDERITEMS.RowID=cte.RowID;

--2. Insert new rows into target table
INSERT INTO EXTR.ORDERITEMS	(
								 RowEffectiveDate	
								,RowExpiryDate
								,RowDateTimeStamp	
								,ORDI
								,UDATE
								,ORD
								,ORDNAME
								,ORDSTATUS
								,ORDSTATUSDES
								,CUST
								,PART
								,QUANT
								,ABALANCE
								,DUEDATE
								,T$USER
								,CLOSED
							)
SELECT	 ERP.calDateTime (T1.UDATE)
		,CAST ('99991231' AS DATETIME)
		,GETDATE()
		,T1.ORDI
		,T1.UDATE
		,T1.ORD
		,T1.ORDNAME
		,T1.ORDSTATUS
		,T1.ORDSTATUSDES
		,T1.CUST
		,T1.PART
		,T1.QUANT
		,T1.ABALANCE
		,T1.DUEDATE
		,T1.T$USER
		,T1.CLOSED
FROM inserted	AS T1;
END;
GO
PRINT N'Creating [ERP].[IntToDateTime]...';


GO
CREATE FUNCTION [ERP].[IntToDateTime] (@dateNum INT) RETURNS TABLE
AS 
	RETURN SELECT IIF(@dateNum=0,NULL, DATEADD(MINUTE,DATEDIFF(MINUTE,0,DATEADD(SECOND,30,CONVERT(DATETIME,CAST(@dateNum AS DECIMAL)/1440+32141))),0)) AS convDateTime;
GO
PRINT N'Creating [ERP].[IntToDate]...';


GO
CREATE FUNCTION [ERP].[IntToDate] (@dateNum INT) RETURNS TABLE
AS 
	RETURN SELECT IIF(@dateNum=0,NULL,CAST(CAST(CAST(@dateNum AS DECIMAL)/1440+32141 AS DATETIME) AS DATE)) AS convDate;
GO
PRINT N'Creating [GEN].[GenerateCalendar]...';


GO
----------------------------------------------------------------------------------------------------
--FUNCTION that generates Calendar
--Source code : http://www.sqlservercentral.com/blogs/dwainsql/2014/03/30/calendar-tables-in-t-sql/
----------------------------------------------------------------------------------------------------

CREATE FUNCTION GEN.GenerateCalendar
        (
			 @FromDate   DATE 
			,@NoDays    INT			
        )

RETURNS TABLE WITH SCHEMABINDING AS
 RETURN
--===== High speed code provided courtesy of SQL MVP Jeff Moden (idea by Dwain Camps)
--===== Generate sequence numbers from 1 to 65536 (credit to SQL MVP Itzik Ben-Gen)
   WITH  E1(N) AS (SELECT 1 UNION ALL SELECT 1), --2 rows
         E2(N) AS (SELECT 1 FROM E1 a, E1 b),    --4 rows
         E4(N) AS (SELECT 1 FROM E2 a, E2 b),    --16 rows
         E8(N) AS (SELECT 1 FROM E4 a, E4 b),    --256 rows
        E16(N) AS (SELECT 1 FROM E8 a, E8 b),    --65536 rows
   cteTally(N) AS (
SELECT TOP (ABS(@NoDays)) ROW_NUMBER() OVER (ORDER BY (SELECT NULL)) FROM E16)
        -- [SeqNo]=Sequential day number (@FromDate always=1) forward or backwards
 SELECT [SeqNo]     = t.N,
		-- [intDate] number of days since 1/1/1900
		[DateInt] =DATEDIFF(day,'1900-1-1', dt.DT),
        -- [Date]=Date (with 00:00:00.000 for the time component)                              
        [DateStr]      = CAST(dt.DT AS DATE),  
        -- [Year]=Four digit year                                  
        [Year]      = dp.YY,
        -- [YrNN]=Two digit year                                    
        [YrNN]      = dp.YY % 100,
        -- [YYYYMM]=Integer YYYYMM (year * 100 + month)                              
        [YYYYMM]    = dp.YY * 100 + dp.MM,
        -- [Month]=Month (as an INT)                             
        [Month]     = dp.MM, 
        -- [Day]=Day (as an INT)                                   
        [Day]       = dp.DD,
        -- [WkDNo]=Week day number (based on @@DATEFIRST)                                    
        [WkDNo]     = DATEPART(dw,dt.DT),
		--Work day :friday and saturday = 0 sunday till thursday =1, holidays will be updated in external procedure
		[workDay] = iif(DATEPART(dw,dt.DT)=6 or DATEPART(dw,dt.DT)=7 ,0,1),
        -- Next 3 columns dependent on language setting so may not work for non-English  
        -- [WkDName]=Full name of the week day, e.g., Monday, Tuesday, etc.                     
        [WkDName]   = CONVERT(NCHAR(9),dp.DW), 
        -- [WkDName2]=Two characters for the week day, e.g., Mo, Tu, etc.                 
        [WkDName2]  = CONVERT(NCHAR(2),dp.DW),  
        -- [WkDName3]=Three characters for the week day, e.g., Mon, Tue, etc.                
        [WkDName3]  = CONVERT(NCHAR(3),dp.DW),  
        -- [JulDay]=Julian day (day number of the year)                
        [JulDay]    = dp.Dy,
        -- [JulWk]=Week number of the year                                    
        [Week]     = dp.WK,
        -- [WkNo]=Week number                                
        [WkNo]      = dp.DD/7+1,
        -- [Qtr]=Quarter number (of the year)                                
        [Qtr]       = DATEPART(qq,dt.DT),                       
        -- [Last]=Number the weeks for the month in reverse      
        [Last]      = (DATEPART(dd,dp.LDtOfMo)-dp.DD)/7+1,
        -- [LdOfMo]=Last day of the month                  
        [LdOfMo]    = DATEPART(dd,dp.LDtOfMo),
        -- [LDtOfMo]=Last day of the month as a DATETIME
        [LDtOfMo]   = dp.LDtOfMo                               
   FROM cteTally t
  CROSS APPLY 
  ( --=== Create the date

        SELECT DT = DATEADD(dd,(t.N-1)*SIGN(@NoDays),@FromDate)
  ) dt
  CROSS APPLY 
  ( --=== Create the other parts from the date above using a "cCA"
    -- (Cascading CROSS APPLY (cCA), courtesy of Chris Morris)
        SELECT  YY        = DATEPART(yy,dt.DT), 
                MM        = DATEPART(mm,dt.DT), 
                DD        = DATEPART(dd,dt.DT), 
                DW        = DATENAME(dw,dt.DT),
                Dy        = DATEPART(dy,dt.DT),
				WK		  = DATEPART(week,dt.DT),	
                LDtOfMo   = DATEADD(mm,DATEDIFF(mm,-1,dt.DT),-1)

  ) dp;
GO
PRINT N'Creating [EXTR].[SERIAL_AfterInsertTrigger]...';


GO
CREATE TRIGGER [EXTR].[SERIAL_AfterInsertTrigger] ON EXTR.SERIAL 
AFTER INSERT
AS
MERGE OPR.WorkOrders AS Target
USING	(

			SELECT	T1.SERIAL					AS WrkOrdID			,
					T1.SERIALNAME				AS WrkOrd			,
					T1.PART						AS PartID			,
					T1.SERIALSTATUS				AS WrkOrdStatID		,
					T1.SERIALSTATUSDES			AS WrkOrdStat		,
					T1.QUANT/10000				AS WrkOrdQuant		,
					F1.convDate					AS WrkOrdClosedDate	,
					F2.convDate					AS WrkOrdCreatedDate,
					F3.convDate					AS WrkOrdStartDate	,
					F4.convDate					AS WrkOrdEndDate	,
					IIF(
							T1.SERIALSTATUS=2 
						OR	T1.SERIALSTATUS=4 
						OR	T1.SERIALSTATUS=5 
						OR	T1.SERIALSTATUS=9
							,1
							,0
						)						AS WrkOrdIsActive

			FROM inserted								AS T1
			CROSS APPLY ERP.IntToDate(T1.CLOSEDATE) 	AS F1
			CROSS APPLY ERP.IntToDate(T1.[CURDATE]) 	AS F2
			CROSS APPLY ERP.IntToDate(T1.PSDATE) 		AS F3
			CROSS APPLY ERP.IntToDate(T1.PEDATE) 		AS F4
	)				AS Source
ON (Target.WrkOrdID=Source.WrkOrdID)
WHEN NOT MATCHED THEN
INSERT	(
			 WrkOrdID
			,WrkOrd
			,PartID
			,WrkOrdStatID
			,WrkOrdStat
			,WrkOrdQuant
			,WrkOrdClosedDate	
			,WrkOrdCreatedDate
			,WrkOrdStartDate
			,WrkOrdEndDate
			,WrkOrdIsActive
			,DateTimeStamp
		)
VALUES	(
			 Source.WrkOrdID
			,Source.WrkOrd
			,Source.PartID
			,Source.WrkOrdStatID
			,Source.WrkOrdStat
			,Source.WrkOrdQuant
			,Source.WrkOrdClosedDate	
			,Source.WrkOrdCreatedDate
			,Source.WrkOrdStartDate
			,Source.WrkOrdEndDate
			,Source.WrkOrdIsActive
			,GETDATE()
		)
WHEN MATCHED THEN
UPDATE SET	 Target.WrkOrdStatID		= Source.WrkOrdStatID
			,Target.WrkOrdStat			= Source.WrkOrdStat
			,Target.WrkOrdQuant			= Source.WrkOrdQuant
			,Target.WrkOrdClosedDate	= Source.WrkOrdClosedDate
			,Target.WrkOrdCreatedDate	= Source.WrkOrdCreatedDate
			,Target.WrkOrdStartDate		= Source.WrkOrdStartDate
			,Target.WrkOrdEndDate		= Source.WrkOrdEndDate
			,Target.WrkOrdIsActive		= Source.WrkOrdIsActive
			,Target.DateTimeStamp		= GETDATE();
GO
PRINT N'Creating [EXTR].[ALINE_AfterInsertTrigger]...';


GO
CREATE TRIGGER EXTR.ALINE_AfterInsertTrigger ON EXTR.ALINE 
AFTER INSERT
AS
MERGE OPR.Production			AS Target
USING	(
		SELECT	AL					AS ProductionRowID		,
				FORM				AS ProductionFormID		,	
				FORMNAME			AS ProductionForm		,	
				SERIAL				AS WrkOrdID				,	
				PART				AS PartID				,
				ACT					AS ActID				,
				IIF(T1.SERCANCEL='Y',1,0) AS ActIsLast		,
				QUANT/10000			AS ProductionPass		,	
				SQUANT/10000		AS ProductionFail		,	
				CURDATE/1440+32141	AS ProductionDateID		,	
				F2.convDateTime		AS ProductionDate		,	
				F3.convDateTime		AS ProductionStartDate	,	
				F4.convDateTime		AS ProductionEndDate	,	
				F1.convDateTime		AS ReportingDateTime	,	
				EMPASPAN			AS ProdTime				,
				WORKC				AS WorkCenterID			,
				SERN				AS UserID									
		FROM inserted			AS T1
		CROSS APPLY ERP.IntToDateTime(T1.UDATE)				AS F1
		CROSS APPLY ERP.IntToDateTime(T1.CURDATE)			AS F2
		CROSS APPLY ERP.IntToDateTime(T1.EMPSDATE)			AS F3
		CROSS APPLY ERP.IntToDateTime(T1.EMPEDATE)			AS F4
		)											AS Source
ON (Target.ProductionRowID=Source.ProductionRowID)
WHEN NOT MATCHED BY Target THEN
INSERT	(
			ProductionRowID		,
			ProductionFormID	,
			ProductionForm		,	
			WrkOrdID			,	
			PartID				,	
			ActID				,
			ActIsLast			,
			ProductionPass		,
			ProductionFail		,	
			ProductionDateID	,	
			ProductionDate		,	
			ProductionStartDate	,	
			ProductionEndDate	,	
			ReportingDateTime	,	
			ProdTime			,	
			WorkCenterID		,	
			UserID				,
			DateTimeStamp			
		)
VALUES	(
			Source.ProductionRowID		,
			Source.ProductionFormID		,	
			Source.ProductionForm		,
			Source.WrkOrdID				,	
			Source.PartID				,	
			Source.ActID				,
			Source.ActIsLast			,
			Source.ProductionPass		,
			Source.ProductionFail		,
			Source.ProductionDateID		,		
			Source.ProductionDate		,	
			Source.ProductionStartDate	,	
			Source.ProductionEndDate	,	
			Source.ReportingDateTime	,	
			Source.ProdTime				,		
			Source.WorkCenterID			,	
			Source.UserID				,
			GETDATE()			
		)
WHEN MATCHED THEN
UPDATE SET	Target.ProductionRowID		= Source.ProductionRowID	,		
			Target.ProductionFormID		= Source.ProductionFormID	,			
			Target.ProductionForm		= Source.ProductionForm		,	
			Target.WrkOrdID				= Source.WrkOrdID			,	
			Target.PartID				= Source.PartID				,		
			Target.ActID				= Source.ActID				,		
			Target.ActIsLast			= Source.ActIsLast			,		
			Target.ProductionPass		= Source.ProductionPass		,	
			Target.ProductionFail		= Source.ProductionFail		,	
			Target.ProductionDateID		= Source.ProductionDateID	,	
			Target.ProductionDate		= Source.ProductionDate		,
			Target.ProductionStartDate	= Source.ProductionStartDate,	
			Target.ProductionEndDate	= Source.ProductionEndDate	,
			Target.ReportingDateTime	= Source.ReportingDateTime	,
			Target.ProdTime				= Source.ProdTime			,	
			Target.WorkCenterID			= Source.WorkCenterID		,	
			Target.UserID				= Source.UserID				,
			Target.DateTimeStamp		= GETDATE()					;
GO
PRINT N'Creating [EXTR].[ORDERITEMS_AfterInsertTrigger]...';


GO
CREATE TRIGGER EXTR.ORDERITEMS_AfterInsertTrigger ON EXTR.ORDERITEMS 
FOR INSERT
AS
BEGIN
IF (SELECT COUNT(*) FROM inserted WHERE CUST<>-4) IS NOT NULL
	BEGIN
	MERGE MKT.ClientOrders									AS Target
	USING	(
				SELECT	ORDI				AS ClientOrderRowID		,
						ORD					AS ClientOrderID		,
						ORDNAME				AS ClientOrder			,
						ORDSTATUS			AS ClientOrderStatusID	,
						ORDSTATUSDES		AS ClientOrderStatus	,
						CUST				AS ClientID				,
						PART				AS PartID				,
						QUANT/10000			AS ClientOrderQuant		,
						ABALANCE/10000		AS ClientOrderBalance	,
						DUEDATE/1440+32141	AS ClientOrderDueDateID	,
						T$USER				AS UserID				,
						IIF(CLOSED='C',0,1)	AS ClientOrderIsOpen	
				FROM inserted
				WHERE CUST <>-4
			)															AS Source
	ON (Target.ClientOrderRowID=Source.ClientOrderRowID)
	WHEN NOT MATCHED BY Target THEN
		INSERT	(
					 ClientOrderRowID
					,ClientOrderID
					,ClientOrder
					,ClientOrderStatusID
					,ClientOrderStatus
					,ClientID
					,PartID
					,ClientOrderQuant
					,ClientOrderBalance
					,ClientOrderDueDateID
					,UserID
					,ClientOrderIsOpen
					,DateTimeStamp
				)
		VALUES	(
					 Source.ClientOrderRowID
					,Source.ClientOrderID
					,Source.ClientOrder
					,Source.ClientOrderStatusID
					,Source.ClientOrderStatus
					,Source.ClientID
					,Source.PartID
					,Source.ClientOrderQuant
					,Source.ClientOrderBalance
					,Source.ClientOrderDueDateID
					,Source.UserID
					,Source.ClientOrderIsOpen
					,GETDATE()
				)
		WHEN MATCHED THEN 
		UPDATE SET	 Target.ClientOrderID		=Source.ClientOrderID
					,Target.ClientOrder			=Source.ClientOrder
					,Target.ClientOrderStatusID	=Source.ClientOrderStatusID
					,Target.ClientOrderStatus	=Source.ClientOrderStatus
					,Target.ClientID			=Source.ClientID
					,Target.PartID				=Source.PartID
					,Target.ClientOrderQuant	=Source.ClientOrderQuant
					,Target.ClientOrderBalance	=Source.ClientOrderBalance
					,Target.ClientOrderDueDateID=Source.ClientOrderDueDateID
					,Target.UserID				=Source.UserID
					,Target.ClientOrderIsOpen	=Source.ClientOrderIsOpen
					,Target.DateTimeStamp		= GETDATE()	;

		END;

	IF (SELECT COUNT(*) FROM inserted WHERE CUST=-4) IS NOT NULL
		BEGIN
			DECLARE @forecasts TABLE	(
											ForecastRowID		INT ,
											ForecastYear		INT	,
											ForecastMonth		INT	,
											PartID				INT	,
											ForecastQuant		INT	,
											ForecastIsOpen		BIT	,
											ForecastUpdatedDate	DATETIME
										);	
			INSERT INTO @forecasts	(
										ForecastRowID	,	
										ForecastYear	,	
										ForecastMonth	,	
										PartID			,	
										ForecastQuant	,	
										ForecastIsOpen	,	
										ForecastUpdatedDate
									)
			SELECT	ORDI				AS ForecastRowID		,
					YEAR(F1.convDate)	AS ForecastYear			,
					MONTH(F1.convDate)	AS ForecastMonth		,
					PART				AS PartID				,		
					QUANT/10000			AS ForecastQuant		,
					IIF(CLOSED='C',0,1)	AS ForecastIsOpen		,
					F2.convDate			AS ForecastUpdatedDate
			FROM inserted
			CROSS APPLY ERP.IntToDate(DUEDATE)	AS F1
			CROSS APPLY	ERP.IntToDate(UDATE)	AS F2
			WHERE CUST =-4 AND DUEDATE >0 ;



			MERGE MKT.Forecasts										AS Target
			USING	(
					SELECT T1.*
					FROM @forecasts AS T1
					CROSS APPLY (
									SELECT TOP (1) ForecastRowID
									FROM @forecasts
									WHERE	ForecastYear	= T1.ForecastYear 
										AND ForecastMonth	= T1.ForecastMonth 
										AND PartID			= T1.PartID
									ORDER BY ForecastUpdatedDate DESC
								) AS T2
					WHERE T1.ForecastRowID=T2.ForecastRowID
					)															AS Source
			ON (Target.ForecastRowID=Source.ForecastRowID)
			WHEN NOT MATCHED BY Target THEN
			INSERT	(
						 ForecastRowID
						,ForecastYear
						,ForecastMonth
						,PartID
						,ForecastQuant
						,ForecastIsOpen
						,ForecastUpdatedDate
						,DateTimeStamp
					)
			VALUES	(
						 Source.ForecastRowID
						,Source.ForecastYear
						,Source.ForecastMonth
						,Source.PartID
						,Source.ForecastQuant
						,Source.ForecastIsOpen
						,Source.ForecastUpdatedDate
						,GETDATE()
					)
			WHEN MATCHED THEN 
			UPDATE SET	 Target.ForecastRowID		=Source.ForecastRowID
						,Target.ForecastYear		=Source.ForecastYear
						,Target.ForecastMonth		=Source.ForecastMonth
						,Target.PartID				=Source.PartID
						,Target.ForecastQuant		=Source.ForecastQuant
						,Target.ForecastIsOpen		=Source.ForecastIsOpen
						,Target.ForecastUpdatedDate	=Source.ForecastUpdatedDate
						,Target.DateTimeStamp		= GETDATE();
		END;
END;
GO
PRINT N'Creating [TRNS].[PartTopBom]...';


GO
/*
Identify the head of hierarchy by parameter. 
Part that dont hold this parameter will not be included in hierarchy.
Updated by Rafi Yedidya engineering dept at פרמטרים < קטגוריה
*/
CREATE FUNCTION TRNS.PartTopBom()
RETURNS @view TABLE
(
	PART		INT	,
	PARTNAME	VARCHAR(22)
)
AS
BEGIN
INSERT @view
SELECT DISTINCT		 T2.PART
					,T2.PARTNAME 
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC		AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PART			AS T2 ON T2.PART=T1.PART
LEFT JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC	AS T3 ON T3.SON=T1.PART
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTSPEC		AS T4 ON T4.PART=T2.PART
WHERE	T3.PART		IS NULL 
	AND (T4.SPEC19	= 'מלאי תוצג' OR T4.SPEC19	= 'תוצ"ג קבל"ש');

RETURN;
END;
GO
PRINT N'Creating [TRNS].[PartActStdTime]...';


GO
CREATE FUNCTION TRNS.PartActStdTime()
RETURNS @view TABLE
(
	PartID			INT		,
	ActID			INT		,
	stdTimeEmployee	FLOAT	,
	stdTimeMachine	FLOAT
)
AS
BEGIN
INSERT @view
SELECT	 P.PART			AS PartID
		,P.ACT			AS ActID
		,ISNULL(P.E,0)	AS stdTimeEmployee
		,ISNULL(P.T,0)	AS stdTimeMachine
FROM
(

	SELECT	 PART	
			,ACT	
			,PARAM	
			,SIZE	
	FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTVAR
	WHERE VALID='Y' AND ACT>0

) AS S
PIVOT
(
	SUM (SIZE)
	FOR PARAM IN (E,T)
) AS P;
RETURN;
END;
GO
PRINT N'Creating [ENG].[PartActHierarchy]...';


GO
CREATE VIEW ENG.PartActHierarchy
AS
SELECT	--T1.PartActBinPath	,
		--T1.PartActBinRoot	,
		T3.PartActID	AS RootPartActID		,
		T1.PartActID		,
		T2.PartID			,
		T2.Part				,
		T2.PartType			,
		T4.ActID			,
		T4.Act				,
		T2.WorkCenterID		,
		T2.WorkCenter		,
		T1.PartActBinPath	,
		T1.PartActBinPath.ToString() AS PartActPath,
		T1.PartActBinPath.GetLevel() AS PartActLevel
FROM TRNS.PartActHierarchy	AS T1
JOIN ENG.PartAct			AS T2 ON T1.PartActID=T2.PartActID
JOIN ENG.PartAct			AS T3 ON T3.PartActBin=T1.PartActBinRoot
OUTER APPLY (
	SELECT p2.PartID,p2.Part,p2.Act,p2.ActID
	FROM TRNS.PartActHierarchy		AS p1
	JOIN ENG.PartAct				AS p2 ON p2.PartActID=p1.PartActID
	WHERE p1.PartActBinPath=t1.PartActBinPath.GetAncestor(1)
) as T4
GO
PRINT N'Creating [ENG].[PartAdjacency]...';


GO
CREATE VIEW ENG.PartAdjacency
AS
SELECT  distinct	t3.PartID			as sonPartID,
		t2.PartID			as parentPartID,
		t3.Part				as sonPart
FROM TRNS.PartActAdjacency	as t1
LEFT JOIN ENG.PartAct		as t2 on t2.PartActID=t1.ParentPartActID
LEFT JOIN ENG.PartAct		as t3 on t3.PartActID=t1.SonPartActID
LEFT JOIN ENG.Parts			as t4 on t4.PartID=t3.PartID
where t4.PartType='P' and t3.WorkCenterID<>114 and t4.FamilyID<>265
GO
PRINT N'Creating [ENG].[PartActAdjacency]...';


GO
CREATE VIEW ENG.PartActAdjacency
AS
SELECT	t1.ParentPartActID	,
		t2.PartID			as parentPartID,
		t2.Part				as parentPart,
		t1.SonPartActID		,
		t3.PartID			as sonPartID,
		t3.Part				as sonPart
FROM TRNS.PartActAdjacency	as t1
LEFT JOIN ENG.PartAct		as t2 on t2.PartActID=t1.ParentPartActID
LEFT JOIN ENG.PartAct		as t3 on t3.PartActID=t1.SonPartActID;
GO
PRINT N'Creating [ENG].[PartActAssembly]...';


GO
CREATE VIEW ENG.PartActAssembly
AS
SELECT	T1.AssemblyID	,
		T1.PartActID			,
		T2.PartID				,
		T2.Part					,
		T2.ActID				,
		T2.Act					,
		T2.ActPos				,
		T1.AssemblyPartID		,
		T3.Part	 AS AssemblyPart,
		T1.AssemblyBinPath	,
		T1.AssemblyBinPath.ToString() AS  AssemblyPath
FROM TRNS.PartActAssembly	AS T1
JOIN ENG.PartAct			AS T2 ON T2.PartActID=T1.PartActID
JOIN ENG.Parts				AS T3 ON T3.PartID=T1.AssemblyPartID
GO
PRINT N'Creating [ERP].[SERIAL]...';


GO
CREATE VIEW ERP.SERIAL
AS
SELECT	 T1.SERIAL
		,T1.SERIALNAME
		,T1.SERIALDES
		,T1.SERIALSTATUS
		,T1.SERIALSTATUSDES
		,T1.PSDATE
		,T1.CLOSED
		,T1.PEDATE
		,T1.QUANT
		,T1.CURDATE
		,T1.CLOSEDATE
		,T1.T$USER
FROM EXTR.SERIAL	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [ERP].[PART]...';


GO
CREATE VIEW ERP.PART
AS
SELECT	 T1.PART
		,T1.PARTNAME
		,T1.PARTDES
		,T1.EPARTDES
		,T1.TYPE
		,T1.T$PROC
		,T1.PROCNAME
		,T1.FAMILY
		,T1.FAMILYNAME
		,T1.FAMILYDES
		,T1.PARTSTAT
		,T1.STATDES
		,T1.SPEC3
		,T1.SPEC4
		,T1.SPEC8
		,T1.SPEC10
		,T1.SPEC19
FROM EXTR.PART	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [ERP].[CUSTOMERS]...';


GO
CREATE VIEW ERP.CUSTOMERS
AS
SELECT	 CUST				
		,UDATE				
		,CUSTNAME			
		,CUSTDES			
		,CUSTSTAT			
		,STATDES			
		,COUNTRY			
		,COUNTRYNAME		
		,CURRENCY	
		,CODE		
		,CTYPE				
		,IVTYPE				
		,SPEC1				
		,SPEC2				
		,SPEC3				
		,SPEC6	
		,SPEC9	
FROM EXTR.CUSTOMERS
WHERE RowExpiryDate>GETDATE();
GO
PRINT N'Creating [ERP].[ALINE]...';


GO
CREATE VIEW ERP.ALINE
AS
SELECT	 RowID
		,AL			
		,UDATE		
		,FORM	
		,FORMNAME		
		,SERIAL			
		,PART			
		,ACT	
		,SERCANCEL						
		,QUANT
		,SQUANT	
		,CURDATE	
		,EMPEDATE	
		,EMPSDATE	
		,EMPASPAN
		,WORKC		
		,SERN	
FROM EXTR.ALINE	
WHERE RowExpiryDate>GETDATE();
GO
PRINT N'Creating [ERP].[PROCACT]...';


GO
CREATE VIEW ERP.PROCACT
AS
SELECT	 T1.RowID
		,T1.RowEffectiveDate
		,T1.RowExpiryDate
		,T1.T$PROC
		,T1.ACT
		,T1.POS
		,T1.ActPos
FROM EXTR.PROCACT	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [ERP].[ORDERITEMS]...';


GO
CREATE VIEW ERP.ORDERITEMS
AS
SELECT	 T1.ORDI
		,T1.UDATE
		,T1.ORD
		,T1.ORDNAME
		,T1.ORDSTATUS
		,T1.ORDSTATUSDES
		,T1.CUST
		,T1.PART
		,T1.QUANT
		,T1.DUEDATE
		,T1.ABALANCE
		,T1.T$USER
		,T1.CLOSED
FROM EXTR.ORDERITEMS	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [EXTR].[PROCACT_Target]...';


GO
CREATE VIEW EXTR.PROCACT_Target
AS
SELECT 	 T1.RowID
		,T1.RowEffectiveDate
		,T1.RowExpiryDate
		,T1.T$PROC
		,T1.ACT
		,T1.POS
		,T1.ActPos
FROM EXTR.PROCACT	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [EXTR].[PARTARC_Target]...';


GO
CREATE VIEW EXTR.PARTARC_Target
AS
SELECT 	 T1.RowID
		,T1.RowEffectiveDate
		,T1.RowExpiryDate
		,T1.PART
		,T1.ACT
		,T1.SON
		,T1.COEF
FROM EXTR.PARTARC	AS T1
WHERE T1.RowExpiryDate>GETDATE();
GO
PRINT N'Creating [MKT].[ActiveClientOrders]...';


GO
CREATE VIEW MKT.ActiveClientOrders
AS
SELECT	 ClientOrderID
		,ClientOrder
		,ClientOrderStatusID
		,ClientOrderStatus
		,ClientID
		,PartID
		,SUM(ClientOrderBalance) AS ClientOrderBalance
		,ClientOrderDueDateID
FROM MKT.ClientOrders
WHERE ClientID <>-4 AND ClientOrderIsOpen=1
GROUP BY ClientOrderID					
		,ClientOrder				
		,ClientOrderStatusID				
		,ClientOrderStatus			
		,ClientID					
		,PartID				
		,ClientOrderDueDateID;
GO
PRINT N'Creating [OPR].[ProductionAct]...';


GO
CREATE VIEW OPR.ProductionAct
AS
SELECT	 ProductionFormID	
		,ProductionForm			
		,WrkOrdID				
		,PartID					
		,ActID				
		,ActIsLast			
		,SUM(ProductionPass)	AS ProductionPassQuant
		,SUM(ProductionFail)	AS ProductionFailQuant	
		,ProductionDateID		
		,ProductionDate		
		,SUM(ProdTime)				AS ProdTime				
		,WorkCenterID				
FROM  OPR.Production	
GROUP BY ProductionFormID	
		,ProductionForm			
		,WrkOrdID				
		,PartID					
		,ActID				
		,ActIsLast
		,ProductionDateID		
		,ProductionDate
		,WorkCenterID	;
GO
PRINT N'Creating [OPR].[ProductionPart]...';


GO
CREATE VIEW OPR.ProductionPart
AS
SELECT	 PartID			
		,SUM(ProductionPass)	AS ProductionPass
		,SUM(ProductionFail)	AS ProductionFail	
		,ProductionDateID		
		,ProductionDate		
		,SUM(ProdTime)				AS ProdTime				
		,WorkCenterID				
FROM  OPR.Production	AS T1
CROSS APPLY	(
				SELECT ProductionRowID
				WHERE WrkOrdID=T1.WrkOrdID AND ActID=T1.ActID AND ActIsLast=1
			)				AS T2
WHERE T1.ProductionRowID=T2.ProductionRowID 
GROUP BY PartID		
		,ProductionDateID		
		,ProductionDate
		,WorkCenterID;
GO
PRINT N'Creating [OPR].[ProductionWrkOrd]...';


GO
CREATE VIEW OPR.ProductionWrkOrd
AS
SELECT	 ProductionFormID	
		,ProductionForm			
		,WrkOrdID				
		,PartID			
		,SUM(ProductionPass)	AS ProductionPass
		,SUM(ProductionFail)	AS ProductionFail	
		,ProductionDateID		
		,ProductionDate		
		,SUM(ProdTime)				AS ProdTime				
		,WorkCenterID				
FROM  OPR.Production	AS T1
CROSS APPLY	(
				SELECT ProductionRowID
				WHERE WrkOrdID=T1.WrkOrdID AND ActID=T1.ActID AND ActIsLast=1
			)				AS T2
WHERE T1.ProductionRowID=T2.ProductionRowID 
GROUP BY ProductionFormID	
		,ProductionForm			
		,WrkOrdID				
		,PartID		
		,ProductionDateID		
		,ProductionDate
		,WorkCenterID;
GO
PRINT N'Creating [EXTR].[PART_InsteadOfTrigger]...';


GO
CREATE TRIGGER EXTR.PART_InsteadOfTrigger ON [EXTR].[PART] 
--Because UDATE allways increases EXTR.PART allways grows (only Inserts, no updates) 
INSTEAD OF INSERT
AS
BEGIN
	TRUNCATE TABLE TRNS.PROCACT;
	--Save all changes in Process of existing part or of a new part
	DECLARE @Processes	TABLE	(PART INT, T$PROC INT);

	INSERT INTO @Processes (PART,T$PROC)
	SELECT DISTINCT T1.PART,T1.T$PROC
	FROM inserted		AS T1
	LEFT JOIN ERP.PART	AS T2 ON T2.PART=T1.PART
	WHERE T1.T$PROC<>ISNULL(T2.T$PROC,0);

	--Updating expiry date for existing rows before inserting new ones:
	WITH cte AS
	(
		SELECT T1.* 
		FROM EXTR.PART	AS T1
		JOIN inserted	AS T2 ON T2.PART=T1.PART
		CROSS APPLY
		(
			SELECT TOP(1)	 RowID	AS ExpiredRowID
							,UDATE	AS ExpiredRowDate
			FROM	EXTR.PART 
			WHERE	PART=T1.PART 
			ORDER BY UDATE DESC
		)							AS T3
		WHERE T1.RowID=T3.ExpiredRowID
	)
	UPDATE EXTR.PART 
	SET RowExpiryDate=cte.RowDateTimeStamp,RowDateTimeStamp=GETDATE()
	FROM cte 
	WHERE EXTR.PART.RowID=cte.RowID;

	--Inserting new rows: 
	INSERT INTO EXTR.PART	(	
								 RowEffectiveDate
								,RowExpiryDate	
								,RowDateTimeStamp
								,PART				
								,UDATE				
								,PARTNAME	
								,PARTDES	
								,EPARTDES	
								,TYPE				
								,T$PROC	
								,PROCNAME		
								,FAMILY	
								,FAMILYNAME	
								,FAMILYDES		
								,PARTSTAT
								,STATDES
								,SPEC3
								,SPEC4
								,SPEC8
								,SPEC10
								,SPEC19
							)
	SELECT	 ERP.calDateTime (T1.UDATE)
			,CAST ('99991231' AS DATETIME)
			,GETDATE()
			,T1.PART				
			,T1.UDATE				
			,T1.PARTNAME
			,T1.PARTDES	
			,T1.EPARTDES			
			,T1.TYPE				
			,T1.T$PROC
			,T1.PROCNAME				
			,T1.FAMILY
			,T1.FAMILYNAME
			,T1.FAMILYDES	
			,T1.PARTSTAT
			,T1.STATDES
			,T1.SPEC3
			,T1.SPEC4
			,T1.SPEC8
			,T1.SPEC10
			,T1.SPEC19
	FROM inserted	 AS T1;

	--Populate TRNS.PartProcess trigger table
	INSERT INTO TRNS.PROCACT(PART,T$PROC,Source)
	SELECT DISTINCT T1.PART,T1.T$PROC,'PART'
	FROM @Processes		AS T1;
END;
GO
PRINT N'Creating [EXTR].[ERP_SERIAL]...';


GO
CREATE PROCEDURE EXTR.ERP_SERIAL
AS
BEGIN

--Find last update date in extraction target table
DECLARE @LastDate INT = ISNULL((SELECT TOP(1) UDATE FROM EXTR.SERIAL ORDER BY UDATE DESC),0);

--Fetch latest updates from ERP system
INSERT INTO EXTR.SERIAL (	
						 RowEffectiveDate	
						,RowExpiryDate
						,RowDateTimeStamp	
						,SERIAL
						,UDATE
						,SERIALNAME
						,SERIALDES
						,SERIALSTATUS
						,SERIALSTATUSDES
						,PSDATE
						,PART
						,CLOSED
						,PEDATE
						,QUANT
						,CURDATE
						,CLOSEDATE
						,T$USER
						)
SELECT	 ERP.calDateTime (T1.UDATE)
		,CAST ('99991231' AS DATETIME)
		,GETDATE()
		,T1.SERIAL
		,T1.UDATE
		,T1.SERIALNAME
		,T1.SERIALDES
		,T2.SERIALSTATUS
		,T3.SERIALSTATUSDES
		,T1.PSDATE
		,T1.PART
		,T1.CLOSED
		,T1.PEDATE
		,T1.QUANT
		,T1.CURDATE
		,T1.CLOSEDATE
		,T1.T$USER
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.SERIAL		AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.SERIALA		AS T2 ON T1.SERIAL=T2.SERIAL
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.SERIALSTATUS	AS T3 ON T3.SERIALSTATUS=T2.SERIALSTATUS
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PART			AS T4 ON T4.PART=T1.PART
WHERE  T1.UDATE>@LastDate AND T4.TYPE='P' AND T2.SERIALSTATUS<>8 ;	--to filter out WMS data only P type parts
END;

--EXEC EXTR.ERP_SERIAL;
GO
PRINT N'Creating [EXTR].[ERP_PART]...';


GO
CREATE PROCEDURE EXTR.ERP_PART
AS
BEGIN 
--Find last update date in extraction target table
DECLARE @LastDate INT = ISNULL((SELECT TOP(1) UDATE FROM EXTR.PART ORDER BY UDATE DESC),0);

--Fetch latest updates from ERP system
INSERT INTO EXTR.PART	(
							 RowEffectiveDate
							,RowExpiryDate	
							,RowDateTimeStamp
							,PART				
							,UDATE				
							,PARTNAME
							,PARTDES
							,EPARTDES			
							,TYPE				
							,T$PROC	
							,PROCNAME		
							,FAMILY	
							,FAMILYNAME
							,FAMILYDES		
							,PARTSTAT	
							,STATDES
							,SPEC3
							,SPEC4
							,SPEC8
							,SPEC10
							,SPEC19
							)
SELECT	 ERP.calDateTime (T1.UDATE)
		,CAST ('99991231' AS DATETIME)
		,GETDATE()
		,T1.PART				
		,T1.UDATE				
		,T1.PARTNAME	
		,T1.PARTDES	
		,T6.EPARTDES		
		,T1.TYPE				
		,T1.T$PROC	
		,T3.PROCNAME		
		,T1.FAMILY	
		,T5.FAMILYNAME
		,T5.FAMILYDES	
		,T1.PARTSTAT	
		,T2.STATDES
		,T4.SPEC3
		,T4.SPEC4
		,T4.SPEC8
		,T4.SPEC10		
		,T4.SPEC19	
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PART			AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTSTATS		AS T2 ON T2.PARTSTAT	= T1.PARTSTAT
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PROCESS		AS T3 ON T3.T$PROC		= T1.T$PROC
LEFT JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTSPEC	AS T4 ON T4.PART		= T1.PART
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.FAMILY		AS T5 ON T5.FAMILY		= T1.FAMILY
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTDES		AS T6 ON T6.PART		= T1.PART
WHERE  T1.UDATE>@LastDate AND T1.PART>0 ;
END;
GO
PRINT N'Creating [EXTR].[ERP_CUSTOMERS]...';


GO
CREATE PROCEDURE EXTR.ERP_CUSTOMERS
AS
BEGIN
--Fetch latest updates from ERP system
DECLARE @LastDate INT = ISNULL((SELECT TOP(1) UDATE FROM EXTR.CUSTOMERS ORDER BY UDATE DESC),0);

INSERT		INTO	EXTR.CUSTOMERS	(
													RowEffectiveDate
													,RowExpiryDate	
													,RowDateTimeStamp
													,CUST				
													,UDATE				
													,CUSTNAME			
													,CUSTDES			
													,CUSTSTAT			
													,STATDES			
													,COUNTRY			
													,COUNTRYNAME		
													,CURRENCY	
													,CODE		
													,CTYPE				
													,IVTYPE				
													,SPEC1				
													,SPEC2				
													,SPEC3				
													,SPEC6			
													,SPEC9	
												)
SELECT	ERP.calDateTime (T2.UDATE)
		,CAST ('99991231' AS DATETIME)
		,GETDATE()
		,T1.CUST
		,T2.UDATE
		,T1.CUSTNAME
		,T1.CUSTDES
		,T1.CUSTSTAT
		,T3.STATDES
		,T1.COUNTRY
		,T5.COUNTRYNAME
		,T1.CURRENCY
		,T6.CODE
		,T1.CTYPE
		,T1.IVTYPE
		,T4.SPEC1
		,T4.SPEC2
		,T4.SPEC3
		,T4.SPEC6
		,T4.SPEC9
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.CUSTOMERS	AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.CUSTOMERSA	AS T2 ON T2.CUST=T1.CUST
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.CUSTSTATS	AS T3 ON T3.CUSTSTAT=T1.CUSTSTAT
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.CUSTSPEC		AS T4 ON T4.CUST=T1.CUST
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.COUNTRIES	AS T5 ON T5.COUNTRY=T1.COUNTRY
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.CURRENCIES	AS T6 ON T6.CURRENCY=T1.CURRENCY
WHERE  T2.UDATE>@LastDate AND T1.CUST>0;



END;
GO
PRINT N'Creating [EXTR].[ERP_ALINE]...';


GO
CREATE PROCEDURE EXTR.ERP_ALINE
AS
BEGIN
DECLARE @LastDate INT = ISNULL((SELECT TOP(1) UDATE FROM EXTR.ALINE ORDER BY UDATE DESC),0);

--Insert new rows into target table
INSERT INTO EXTR.ALINE	(
							RowEffectiveDate	,
							RowExpiryDate		,
							RowDateTimeStamp	,
							AL					,
							UDATE				,
							FORM				,
							FORMNAME			,
							SERIAL				,
							PART				,
							ACT					,
							SERCANCEL			,
							CURDATE				,
							QUANT				,
							SQUANT				,
							EMPEDATE			,
							EMPSDATE			,
							EMPASPAN			,
							WORKC				,
							SERN	
						) 
SELECT
				 ERP.calDateTime (T1.UDATE)
				,CAST ('99991231' AS DATETIME)
				,GETDATE()
			 	,T1.AL			
				,T1.UDATE		
				,T1.FORM	
				,T2.FORMNAME		
				,T1.SERIAL			
				,T1.PART			
				,T1.ACT	
				,T1.SERCANCEL
				,T1.CURDATE	
				,T1.QUANT
				,T1.SQUANT	
				,T1.EMPEDATE	
				,T1.EMPSDATE	
				,T1.EMPASPAN
				,T1.WORKC		
				,T1.SERN	 
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.ALINE	AS T1 
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.AFORM	AS T2 ON T2.FORM=T1.FORM 
WHERE  T1.UDATE>@LastDate;
END;
GO
PRINT N'Creating [EXTR].[ERP_PROCACT]...';


GO
/*
This procedure executes 2 tasks :
	FIRST : Merge data into EXTR.PROCACT.
	SECOND: Refreshe (truncate and populate) TRNS.PartProcess table.
*/
CREATE PROCEDURE EXTR.ERP_PROCACT
AS
BEGIN
TRUNCATE TABLE TRNS.PROCACT;

/*
First insert all updated processes into @Process in order to keep them (but not to TRNS.PROCACT table yet,
because updating TRNS.PROCACT will fire trigger to execute TRNS.PROCACT_ActPos)
*/
DECLARE @Process AS TABLE (T$PROC INT);

/*
Merge data into EXTR.PROCACT, will NOT fire trigger to execute LOAD.PROCACT_PartAct,
because this trigger fires only after update.  EXTR.PROCACT will be updated after 
@Process will be inserted into TRNS.PROCACT , and only then trigger will be fired to update  EXTR.PROCACT.
*/
INSERT INTO @Process (T$PROC)	
SELECT	T1.T$PROC
FROM
(

	MERGE EXTR.PROCACT_Target	WITH (HOLDLOCK)												AS Target	--TARGET
	USING 
		(																								--SOURCE
			SELECT	DISTINCT T1.T$PROC,																	--SOURCE
			T1.ACT,																						--SOURCE
			T1.POS,																						--SOURCE
			ROW_NUMBER()		OVER (PARTITION BY T1.T$PROC ORDER BY T1.POS)	AS ActPos				--SOURCE
			FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PROCACT	AS T1							--SOURCE
			WHERE T1.ACT>0 OR T1.ACT=-8																	--SOURCE
		)																					AS Source	--SOURCE
	ON	(
			Target.T$PROC	= Source.T$PROC		AND
			Target.ACT		= Source.ACT		AND
			Target.POS		= Source.POS
		)
	WHEN NOT MATCHED BY Target THEN
		INSERT	(
					RowEffectiveDate,
					RowExpiryDate	,
					T$PROC			,		
					ACT				,			
					POS				,
					ActPos	
				)
		VALUES	(
					GETDATE()						,
					CAST ('99991231' AS DATETIME)	,
					Source.T$PROC					,		
					Source.ACT						,		
					Source.POS						,	
					Source.ActPos
				)
	WHEN NOT MATCHED BY Source THEN
		UPDATE SET	Target.RowExpiryDate	= GETDATE(),ActPos=NULL	
	OUTPUT	COALESCE(INSERTED.RowID	, DELETED.RowID)	,
			$action										,
			COALESCE(INSERTED.T$PROC, DELETED.T$PROC)	,		
			COALESCE(INSERTED.ACT	, DELETED.ACT)		,
			COALESCE(INSERTED.POS	, DELETED.POS)		,
			COALESCE(INSERTED.ActPos, DELETED.ActPos)
) AS T1	(
			RowID		,
			RowChange	,
			T$PROC		,
			ACT			,
			POS			,
			ActPos	
		);

--2. Populate EXTR.Processes : Processes that are connected to parts only.

INSERT INTO TRNS.PROCACT (PART,T$PROC,Source)
SELECT DISTINCT T2.PART,T1.T$PROC,'PROCACT'
FROM @Process		AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PART	AS T2 ON T2.T$PROC=T1.T$PROC;
END;
GO
PRINT N'Creating [EXTR].[ERP_ORDERITEMS]...';


GO
CREATE PROCEDURE EXTR.ERP_ORDERITEMS
AS
BEGIN 
--Find last update date in extraction target table
DECLARE @LastDate INT = ISNULL((SELECT TOP(1) UDATE FROM EXTR.ORDERITEMS ORDER BY UDATE DESC),0);

--Fetch latest updates from ERP system
INSERT INTO EXTR.ORDERITEMS	(
								RowEffectiveDate	,
								RowExpiryDate		,
								RowDateTimeStamp	,
								ORDI				,
								UDATE				,
								ORD					,
								ORDNAME				,
								ORDSTATUS			,
								ORDSTATUSDES		,
								CUST				,	
								PART				,
								QUANT				,	
								ABALANCE			,
								DUEDATE				,
								T$USER			,
								CLOSED		
							)
SELECT	ERP.calDateTime (T1.UDATE)		,
		CAST ('99991231' AS DATETIME)	,
		GETDATE()						,
		T1.ORDI							,
		T1.UDATE						,
		T2.ORD							,
		T2.ORDNAME						,
		T2.ORDSTATUS					,
		T3.ORDSTATUSDES					,
		T2.CUST							,
		T1.PART							,
		T1.QUANT						,
		T1.ABALANCE						,
		T1.DUEDATE						,
		T1.T$USER						,
		T1.CLOSED
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.ORDERITEMS		AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.ORDERS			AS T2 ON T2.ORD	=	T1.ORD
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.ORDSTATUS			AS T3 ON T3.ORDSTATUS=T2.ORDSTATUS
WHERE	T2.ORDSTATUS	<>-6 
	AND T2.ORD			> 0 
	AND T2.CUST			<>940	--Afula warehouse
	AND T2.CUST			<>1009	--Alon tavor warehouse
	AND T2.CUST			<>1141	--Lod warehouse
	AND T1.PART			> 0
	AND T1.UDATE		> @LastDate;
END;
GO
PRINT N'Creating [EXTR].[ERP_PARTARC]...';


GO
CREATE PROCEDURE EXTR.ERP_PARTARC
AS
BEGIN
DECLARE @PARTARC AS TABLE	(
								RowChange	VARCHAR(10),
								PART		INT	,
								ACT			INT	,
								SON			INT	,
								COEF		FLOAT
							);
TRUNCATE TABLE TRNS.PARTARC;
INSERT INTO @PARTARC	(
								RowChange,
								PART	,
								ACT		,
								SON		,
								COEF
						)
SELECT	T1.RowChange,
		T1.PART		,
		T1.ACT		,
		T1.SON		,
		T1.COEF
FROM
(
	MERGE EXTR.PARTARC_Target	WITH (HOLDLOCK)												AS Target	--TARGET
	USING 
		(																								--SOURCE
			SELECT	DISTINCT	T1.PART,																--SOURCE
								T1.ACT,																	--SOURCE
								T1.SON,																	--SOURCE
								T1.COEF																	--SOURCE
			FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC	AS T1							--SOURCE
			WHERE T1.SONACT=-3																				--SOURCE
		)																					AS Source	--SOURCE
	ON	(
			Target.PART	= Source.PART	AND
			Target.ACT	= Source.ACT	AND
			Target.SON	= Source.SON	
		)
	WHEN NOT MATCHED BY Target THEN
		INSERT	(
					RowEffectiveDate,
					RowExpiryDate	,
					PART			,
					ACT				,		
					SON				,			
					COEF		
				)
		VALUES	(
					GETDATE()						,
					CAST ('99991231' AS DATETIME)	,
					Source.PART						,	
					Source.ACT						,	
					Source.SON						,		
					Source.COEF						
				)
	WHEN NOT MATCHED BY Source THEN
		UPDATE SET	Target.RowExpiryDate	= GETDATE()
	OUTPUT	$action										,
			COALESCE(INSERTED.PART	, DELETED.PART)		,		
			COALESCE(INSERTED.ACT	, DELETED.ACT)		,		
			COALESCE(INSERTED.SON	, DELETED.SON)		,
			COALESCE(INSERTED.COEF	, DELETED.COEF)		
)	AS T1	(
				RowChange	,
				PART		,
				ACT			,
				SON			,
				COEF	
			);

INSERT INTO TRNS.PARTARC	(
								RowChange	,
								PART		,
								ACT			,
								SON			,
								COEF	
							)
SELECT	T1.RowChange	,
		T1.PART			,
		T1.ACT			,
		T1.SON			,
		T1.COEF
FROM @PARTARC AS T1

END;
GO
PRINT N'Creating [LOAD].[PART_PartAct]...';


GO
/*
This procedure updates ENG.PartAct target table, with changes accur in cele.dbo.PART that effect Process.
The procedure is fired by EXTR.PART_InsteadOfTrigger.
*/
CREATE PROCEDURE LOAD.PART_PartAct
AS 
BEGIN
--In cele.dbo.PART changes are in the level of PART (T$PROC changes for a PART)
--In cele.dbo.PROCACT changes are in the level of the process (ACT changes for T$PROC)

--Delete from ENG.PartAct all Part row/s
DELETE T1
FROM ENG.PartAct T1
JOIN TRNS.PROCACT T2 on T2.PART=T1.PartID;

--Insert new data row/s

INSERT INTO ENG.PartAct	(
							PartID			,
							Part			,
							PartType		,
							PartIsRoot		,
							PartIsActive	,
							ProcessID		,
							ActID			,
							Act				,
							ActPos			,
							PrevActID		,
							NextActID		,
							ActIsLast		,
							WorkCenterID	,
							WorkCenter		,
							stdTimeEmployee	,
							stdTimeMachine	,
							DateTimeStamp	,
							Source		
							)
SELECT	PartID			,
		Part			,
		PartType		,
		PartIsRoot		,
		PartIsActive	,
		ProcessID		,
		ActID			,
		Act				,
		ActPos			,
		PrevActID		,
		NextActID		,
		ActIsLast		,
		WorkCenterID	,
		WorkCenter		,
		stdTimeEmployee	,
		stdTimeMachine	,
		GETDATE()		,
		'PART'		
FROM TRNS.PartAct
END;
GO
PRINT N'Creating [LOAD].[PROCACT_PartAct]...';


GO
CREATE PROCEDURE LOAD.PROCACT_PartAct
--Nested procedure in EXTR.ERP_PROCACT for updating ENG.PartAct
AS
BEGIN


--1. Merge changes with ENG.PartAct
WITH cte AS
(
	SELECT T1.*
	FROM ENG.PartAct AS T1
	JOIN TRNS.PROCACT			AS T2 ON T2.T$PROC=T1.ProcessID AND T2.PART=T1.PartID
)
MERGE cte WITH (HOLDLOCK)				AS Target
USING	(SELECT	* FROM TRNS.PartAct)	AS Source
ON		(
			Target.ProcessID= Source.ProcessID	AND
			Target.ActID	= Source.ActID		AND
			Target.ActPos	= Source.ActPos
		)
WHEN NOT MATCHED BY Target THEN
INSERT	(
			PartID			,
			Part			,
			PartType		,
			PartIsRoot		,
			PartIsActive	,
			ProcessID		,
			ActID			,
			Act				,
			ActPos			,
			PrevActID		,
			NextActID		,
			ActIsLast		,
			WorkCenterID	,
			WorkCenter		,
			stdTimeEmployee	,
			stdTimeMachine	,
			DateTimeStamp	,
			[Source]		
		)

VALUES	(
			Source.PartID			,
			Source.Part				,
			'P'						,
			Source.PartIsRoot		,
			Source.PartIsActive		,
			Source.ProcessID		,
			Source.ActID			,
			Source.Act				,
			Source.ActPos			,
			Source.PrevActID		,
			Source.NextActID		,
			Source.ActIsLast		,
			Source.WorkCenterID		,
			Source.WorkCenter		,
			Source.stdTimeEmployee	,
			Source.stdTimeMachine	,
			GETDATE()				,
			'PROCACT'		
		)
WHEN NOT MATCHED BY Source THEN 
DELETE;

--2.
DELETE ENG.PartAct WHERE ActPos IS NULL;

END;
GO
PRINT N'Creating [LOAD].[PARTARC_PartAct]...';


GO
CREATE PROCEDURE LOAD.PARTARC_PartAct
AS 
BEGIN
with cte as 
(
	select	T1.PartID			,
			T1.Part				,
			T1.PartType			,
			T1.DateTimeStamp	,
			T1.[Source]
	FROM ENG.PartAct	AS T1
	JOIN TRNS.PARTARC	AS T2 ON T1.PartID=T2.SON
	WHERE T1.PartType='R'
)
MERGE cte														AS Target
USING	(				
			SELECT DISTINCT		T2.PartID	,					--Source
								T2.Part		,					--Source
								T2.PartType						--Source
			FROM TRNS.PARTARC	AS T1
			JOIN ENG.Parts		AS T2 ON T2.PartID=T1.SON
		)														AS Source 
ON	(
		Target.PartID=Source.PartID
	)
WHEN NOT MATCHED BY Target THEN
INSERT	(
			PartID			,
			Part			,
			PartType		,
			DateTimeStamp	,
			[Source]		
		)
VALUES	(
			Source.PartID	,
			Source.Part		,
			Source.PartType	,
			GETDATE()		,
			'PARTARC'
		)

WHEN NOT MATCHED BY Source AND Target.PartType='R' THEN
DELETE;
END;
GO
PRINT N'Creating [TRNS].[ERP_PartActAdjacency]...';


GO
CREATE PROCEDURE TRNS.ERP_PartActAdjacency
AS 
BEGIN
TRUNCATE TABLE TRNS.PartActAdjacency;
WITH cte AS
(
--Root Parts
SELECT				 NULL			AS ParentPartActID
					,NULL			AS ParentID 
					,T.PartActID	AS SonPartActID
					,T.PartID		AS SonID
					,1				AS SonPartActCoef
					,T.ActDays		AS SonActDays			
FROM ENG.PartAct AS T
WHERE T.PartIsRoot=1
		
UNION ALL

--Linking two different parts (using PARTARC)
SELECT DISTINCT		 T3.PartActID	AS ParentPartActID
					,T3.PartID		AS ParentID
					,T4.PartActID	AS SonPartActID
					,T1.SON			AS SonID
					,T1.COEF		AS SonPartActCoef
					,T4.ActDays		AS SonActDays
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC		AS T1
JOIN ENG.PartAct					AS T3 ON T3.PartID	= T1.PART	AND T3.ActPos=1
JOIN ENG.PartAct					AS T4 ON T4.PartID	= T1.SON	AND T4.ActIsLast=1

UNION ALL 

--Same part (using PartAct)
SELECT	 T1.PartActID	AS ParentPartActID
		,T1.PartID		AS ParentID
		,T2.PartActID	AS SonPartActID
		,T2.PartID		AS SonID
		,1				AS SonPartActCoef
		,T2.ActDays		AS SonActDays
FROM ENG.PartAct		AS T1
JOIN ENG.PartAct		AS T2 ON	T2.PartID=T1.PartID AND	T2.ActID=T1.PrevActID

--Edge parts
UNION ALL

SELECT	 T2.PartActID	AS ParentPartActID
		,T1.PART		AS ParentID
		,NULL			AS SonPartActID
		,NULL			AS SonID
		,NULL			AS SonPartActCoef
		,NULL			AS SonActDays
FROM [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC	AS T1
CROSS APPLY	(
				SELECT PartActID 
				FROM ENG.PartAct
				WHERE PartID=T1.PART AND ActID=T1.ACT
			)		AS T2
GROUP BY T2.PartActID,T1.PART,T1.ACT
HAVING SUM(IIF(T1.SONACT<>-3,1,0))=0

--Assembly parts
UNION ALL

SELECT  T1.PartActID		AS ParentPartActID	,
		T3.PartID			AS ParentID			,
		T2.PartActID		AS SonPartActID		,
		T2.PartID			AS SonID			,
		NULL				AS SonPartActCoef	,
		NULL				AS SonActDays
FROM TRNS.PartActAssembly	AS T1
JOIN ENG.PartAct			AS T2 ON T2.PartID=T1.AssemblyPartID
JOIN ENG.PartAct			AS T3 ON T3.PartActID=T1.PartActID

--
)
INSERT INTO TRNS.PartActAdjacency	(
										 ParentPartActID
										,SonPartActID
										,SonRowNum
										,SonPartActCoef
										,SonActDays
									)
SELECT	 T.ParentPartActID
		,T.SonPartActID
		,ROW_NUMBER() OVER(PARTITION BY T.ParentID ORDER BY T.SonID)
		,T.SonPartActCoef
		,T.SonActDays
FROM cte AS T;


END;
GO
PRINT N'Creating [TRNS].[ERP_PartAct]...';


GO

/*
This procedure outputs updated PartAct rows into  TRNS.PartAct table.
The procedure is executed after TRNS.PROCACT is populated.
*/
CREATE PROCEDURE TRNS.ERP_PartAct

AS
BEGIN
TRUNCATE TABLE TRNS.PartAct;
WITH cte AS
(
SELECT	T4.PART															AS PartID			,
		T4.PARTNAME														AS Part				,
		T4.TYPE															AS PartType			,
		IIF(T8.PART IS NULL,0,1)										AS PartIsRoot		,
		IIF(T4.PARTSTAT=1 OR T4.PARTSTAT=-2,0,1)						AS PartIsActive		,
		T2.T$PROC														AS ProcessID		,
		T2.ACT															AS ActID			,
		T5.ACTNAME														AS Act				,
		T2.POS																				,													
		T6.WORKC														AS WorkCenterID		,
		T6.WORKCNAME													AS WorkCenter		,
		LAST_VALUE(T2.ACT) OVER (
									PARTITION BY T2.T$PROC 
									ORDER BY T2.POS ROWS 
									BETWEEN UNBOUNDED PRECEDING 
									AND		UNBOUNDED FOLLOWING
								)										AS LastActId		,
		T7.stdTimeEmployee												AS stdTimeEmployee	,
		T7.stdTimeMachine												AS stdTimeMachine
FROM TRNS.PROCACT				AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PROCACT	AS T2 ON T2.T$PROC=T1.T$PROC
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PART		AS T4 ON T4.T$PROC=T1.T$PROC AND T4.PART=T1.PART
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.ACT		AS T5 ON T5.ACT=T2.ACT
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.WORKC	AS T6 ON T6.WORKC=T5.WORKC
LEFT JOIN TRNS.PartActStdTime()			AS T7 ON T7.PartID=T4.PART AND T7.ActID=T5.ACT	--Left join is required, not all Act std Time is updated/syncronized !!!
OUTER APPLY	(
				 SELECT PART 
				 FROM TRNS.PartTopBom()		
				 WHERE PART=T1.PART
			)							AS T8
WHERE  T5.ACT	>0
)
INSERT TRNS.PartAct(
				 PartID			
				,Part	
				,PartType		
				,PartIsRoot		
				,PartIsActive	
				,ProcessID		
				,ActID			
				,Act			
				,ActPos			
				,PrevActID		
				,NextActID		
				,ActIsLast		
				,WorkCenterID	
				,WorkCenter		
				,stdTimeEmployee
				,stdTimeMachine	
			)
SELECT			 PartID			
				,Part	
				,PartType		
				,PartIsRoot		
				,PartIsActive	
				,ProcessID		
				,ActID			
				,Act			
				,ROW_NUMBER()	OVER (PARTITION BY PartID,ProcessID ORDER BY POS)	AS ActPos	
				,LAG(ActID,1,0)  OVER (PARTITION BY PartID,ProcessID ORDER BY POS)	AS PrevActID		
				,LEAD(ActID,1,0) OVER (PARTITION BY PartID,ProcessID ORDER BY POS)	AS NextActID			
				,IIF(LastActId=ActID,1,0)											AS ActIsLast		
				,WorkCenterID	
				,WorkCenter		
				,stdTimeEmployee
				,stdTimeMachine	
			
FROM cte

RETURN;
END;
GO
PRINT N'Creating [TRNS].[PROCACT_ActPos]...';


GO
/*
This procedure is fired by TRNS.PartProcess_AfterInsertTrigger ON TRNS.PartProcess
*/
CREATE PROCEDURE TRNS.PROCACT_ActPos 
AS
BEGIN

--1. Recalculate and Update ActPos for all Acts of the Process that was updated.
	WITH cte AS
	(
		SELECT	T1.T$PROC,
				T1.ACT,
				ROW_NUMBER()	OVER (PARTITION BY T1.T$PROC ORDER BY T1.POS) AS ActPos
		FROM ERP.PROCACT	AS T1
	)
	UPDATE ERP.PROCACT
	SET ActPos=T2.ActPos
	FROM ERP.PROCACT		AS T1
	JOIN cte				AS T2 ON T2.T$PROC=T1.T$PROC AND T1.ACT=T2.ACT
	JOIN TRNS.PROCACT	AS T3 ON  T3.T$PROC=T1.T$PROC;

--2. Truncate TRNS.PartProcess after finishing using it.
	--TRUNCATE TABLE TRNS.PartProcess;

END;
--Nested procedure in EXTR.ERP_PROCACT for recalculating ActPos
GO
PRINT N'Creating [TRNS].[ERP_PartActHierarchy]...';


GO
CREATE PROCEDURE TRNS.ERP_PartActHierarchy
AS
BEGIN
TRUNCATE TABLE TRNS.PartActHierarchy;
WITH cte AS
(	
	SELECT	  T1.SonPartActID															AS PartActID	
			 ,CAST('/' + CAST(T1.SonRowNum AS VARCHAR(10))+'/'		AS VARCHAR(900))	AS PartActBinPath
			 ,CAST('/' + CAST(T1.SonPartActID AS VARCHAR(10))+'/'	AS VARCHAR(900))	AS PartActBinRoot										
			 ,1																			AS PartActLev
			 ,T1.SonPartActCoef															AS PartActCoef
			 ,T1.SonActDays															AS ActDays
	FROM TRNS.PartActAdjacency		AS T1
	WHERE ParentPartActID IS NULL

	UNION ALL

	SELECT	 S.SonPartActID
			,CAST(PartActBinPath + CAST(S.SonRowNum AS VARCHAR(20)) + '/' AS VARCHAR(900))
			,P.PartActBinRoot
			,P.PartActLev+1
			,P.PartActCoef*S.SonPartActCoef
			,P.ActDays+S.SonActDays
	FROM cte			AS P
	JOIN TRNS.PartActAdjacency	AS S ON S.ParentPartActID=P.PartActID
) 
INSERT INTO TRNS.PartActHierarchy	(
										 PartActID
										,PartActBinPath
										,PartActBinRoot
										,PartActCoef
										,ActDays	
									)
SELECT	 T.PartActID
		,T.PartActBinPath
		,T.PartActBinRoot
		,T.PartActCoef
		,T.ActDays
FROM cte	AS T
WHERE T.PartActID IS NOT NULL;
END;
GO
PRINT N'Creating [TRNS].[ERP_PartActAssembly]...';


GO
CREATE PROCEDURE TRNS.ERP_PartActAssembly
AS
TRUNCATE TABLE TRNS.PartActAssembly;
INSERT INTO TRNS.PartActAssembly	(
										 PartActID
										,AssemblyPartID
										,AssemblyBinPath
									)
SELECT	 T1.PartActID
		,T2.SON	
		,CAST('/'+ CAST(ROW_NUMBER() OVER (PARTITION BY T1.PartActID ORDER BY T2.SON) AS VARCHAR(3)) +'/' AS HIERARCHYID) 
FROM ENG.PartAct											AS T1
JOIN [$(PriorityServer)].[$(PriorityDatabase)].dbo.PARTARC	AS T2 ON T2.PART=T1.PartID AND T2.ACT=T1.ActID
WHERE T2.SONACT=-3;
GO
PRINT N'Creating [ENG].[ENG_PartAct_AfterUpdateTrigger]...';


GO
/*
This trigger executes TRNS.ERP_PartActAdjacency that rebuilds TRNS.PartActAdjacency table from scratch.
*/
CREATE TRIGGER ENG.ENG_PartAct_AfterUpdateTrigger ON ENG.PartAct 
AFTER INSERT,UPDATE,DELETE
AS 
BEGIN
--Dont execute where deleted/inserted data is assembly parts 
IF EXISTS (SELECT 1 FROM inserted WHERE PartType='P') OR EXISTS (SELECT 1 FROM deleted WHERE PartType='P')
BEGIN
	EXEC TRNS.ERP_PartActAdjacency;
END

END;
GO
PRINT N'Creating [EXTR].[PROCACT_AfterUpdateTrigger]...';


GO
/*
This trigger will be fired only when [EXTR].[PROCACT] is updated.
[EXTR].[PROCACT] table is updated by PROCACT_ActPos procedure, that is executed 
after TRNS.PROCACT is populated.
This trigger will NOT be fired after data is inserted to [EXTR].[PROCACT],
by EXTR.ERP_PROCACT procedure.
*/
CREATE TRIGGER EXTR.PROCACT_AfterUpdateTrigger ON EXTR.PROCACT
AFTER UPDATE
AS
IF EXISTS(SELECT * FROM TRNS.PROCACT) EXEC LOAD.PROCACT_PartAct;
GO
PRINT N'Creating [TRNS].[TRNS_PartActAdjacency_AfterUpdateTrigger]...';


GO
/*
This trigger executes TRNS.ERP_PartActHierarchy that rebuilds TRNS.PartActHierarchy table from scratch.
*/
CREATE TRIGGER TRNS.TRNS_PartActAdjacency_AfterUpdateTrigger ON TRNS.PartActAdjacency
AFTER INSERT,UPDATE,DELETE
AS 
BEGIN
	EXEC TRNS.ERP_PartActHierarchy;
END;
GO
PRINT N'Creating [TRNS].[PartProcess_AfterInsertTrigger]...';


GO
CREATE TRIGGER TRNS.PartProcess_AfterInsertTrigger ON TRNS.PROCACT
AFTER INSERT
AS
BEGIN
	--Populate TRNS.PartAct table
	EXEC TRNS.ERP_PartAct;

	DECLARE @source VARCHAR(10);
	SELECT @source=Source FROM inserted;
	--If TRNS.PartProcess was changed by PROCACT then reset ActPos in EXTR.PROCACT table an only then execute LOAD.PROCACT_PartAct
	IF @source='PROCACT' EXEC TRNS.PROCACT_ActPos;
	--If TRNS.PartProcess was changed by PART
	IF @source='PART' EXEC LOAD.PART_PartAct;
	
END;
GO
PRINT N'Creating [TRNS].[TRNS_PartActAssembly_AfterInserTrigger]...';


GO
CREATE TRIGGER TRNS.TRNS_PartActAssembly_AfterInserTrigger ON TRNS.PartActAssembly
AFTER INSERT, DELETE
AS
BEGIN
		EXEC TRNS.ERP_PartActAdjacency;
END;
GO
PRINT N'Creating [TRNS].[PARTARC_AfterInsertTrigger]...';


GO
CREATE TRIGGER TRNS.PARTARC_AfterInsertTrigger ON TRNS.PARTARC
--
AFTER INSERT
AS 
BEGIN
	--Insert into TRNS.PartActAssembly TRNS.PARTARC inserted rows - will fire the trigger to update ENG.PartAct
	INSERT INTO TRNS.PartActAssembly	(
											PartActID	,
											AssemblyPartID
										)
	SELECT	T2.PartActID	,
			T1.SON
	FROM TRNS.PARTARC	AS T1
	JOIN ENG.PartAct	AS T2 ON T2.PartID=T1.PART AND T2.ActID=T1.ACT
	WHERE T1.RowChange='INSERT';

	--Delete from TRNS.PartActAssembly TRNS.PARTARC deleted rows - will fire the trigger to update ENG.PartAct
	WITH cte 
	AS
	(
		SELECT	T1.PART		,
				T1.ACT		,
				T1.SON		,
				T2.PartActID
		FROM TRNS.PARTARC	AS T1
		JOIN ENG.PartAct	AS T2 ON  T2.PartID=T1.PART AND T2.ActID=T1.ACT
		WHERE T1.RowChange='UPDATE'
	)
	DELETE T3
	FROM cte 
	JOIN TRNS.PartActAssembly	AS T3 ON T3.PartActID=cte.PartActID AND T3.AssemblyPartID=cte.SON;

	--Merge assembly parts into PartAct
	EXEC LOAD.PARTARC_PartAct;
	
END;
GO
-- Refactoring step to update target server with deployed transaction logs

IF OBJECT_ID(N'dbo.__RefactorLog') IS NULL
BEGIN
    CREATE TABLE [dbo].[__RefactorLog] (OperationKey UNIQUEIDENTIFIER NOT NULL PRIMARY KEY)
    EXEC sp_addextendedproperty N'microsoft_database_tools_support', N'refactoring log', N'schema', N'dbo', N'table', N'__RefactorLog'
END
GO
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'f341a09c-04ed-40fd-b1a6-51ab2e99d09d')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('f341a09c-04ed-40fd-b1a6-51ab2e99d09d')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '3dd34fa9-a560-4227-af84-79995a7d8e6d')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('3dd34fa9-a560-4227-af84-79995a7d8e6d')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '036aa9db-2edd-4db8-b2e7-5834f5c08474')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('036aa9db-2edd-4db8-b2e7-5834f5c08474')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = '76b2b8f4-b2a3-4487-93d8-42aca1b4dd3c')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('76b2b8f4-b2a3-4487-93d8-42aca1b4dd3c')
IF NOT EXISTS (SELECT OperationKey FROM [dbo].[__RefactorLog] WHERE OperationKey = 'b4a97dca-ca19-4c82-be20-2091d7af6bce')
INSERT INTO [dbo].[__RefactorLog] (OperationKey) values ('b4a97dca-ca19-4c82-be20-2091d7af6bce')

GO

GO
DECLARE @VarDecimalSupported AS BIT;

SELECT @VarDecimalSupported = 0;

IF ((ServerProperty(N'EngineEdition') = 3)
    AND (((@@microsoftversion / power(2, 24) = 9)
          AND (@@microsoftversion & 0xffff >= 3024))
         OR ((@@microsoftversion / power(2, 24) = 10)
             AND (@@microsoftversion & 0xffff >= 1600))))
    SELECT @VarDecimalSupported = 1;

IF (@VarDecimalSupported > 0)
    BEGIN
        EXECUTE sp_db_vardecimal_storage_format N'$(DatabaseName)', 'ON';
    END


GO
PRINT N'Update complete.';


GO
